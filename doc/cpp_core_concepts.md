# C++核心概念技术笔记

## 目录
1. [C++语言基础](#c语言基础)
2. [面向对象编程](#面向对象编程)
3. [C++11/14/17新特性](#c111417新特性)
4. [内存管理](#内存管理)
5. [STL库使用与原理](#stl库使用与原理)
6. [多线程与并发](#多线程与并发)

---

## C++语言基础

### 数据类型与类型转换
- 基本数据类型、自定义类型
- 隐式转换与显式转换
- `static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`的区别与使用场景

### 函数高级特性
- 函数重载与参数匹配规则
- 默认参数与陷阱
- 内联函数优化
- 函数指针与函数对象

### 预处理器与宏定义
- 条件编译技术
- 宏定义的优缺点
- 宏与内联函数的选择

## 面向对象编程

### 类与对象
- 封装、继承、多态的实现机制
- 构造函数、析构函数、拷贝构造、移动语义
- 虚函数表与动态绑定原理

### 继承与组合
- 公有继承、保护继承、私有继承的区别
- 虚继承解决菱形继承问题
- 组合优于继承原则

### 多态与虚函数
- 纯虚函数与抽象类
- 运行时多态与编译时多态
- 虚析构函数的必要性
- override与final关键字

## C++11/14/17新特性

### 现代C++语法
- auto与decltype类型推导
- 范围for循环
- 统一初始化列表
- 委托构造函数

### 智能指针
- `shared_ptr`实现原理与使用
- `unique_ptr`的独占所有权
- `weak_ptr`解决循环引用
- 自定义删除器

### Lambda表达式
- 捕获列表、参数列表、返回值
- 闭包与函数对象的关系
- Lambda在STL算法中的应用

### 右值引用与移动语义
- 左值与右值的区别
- std::move的实现与使用
- 完美转发std::forward
- 移动构造函数与移动赋值运算符

## 内存管理

### 内存模型
- 栈、堆、全局/静态区、常量区、代码区
- 对象生命周期管理
- RAII设计模式

### 内存分配
- new/delete与malloc/free的区别
- placement new的使用
- 内存池与自定义分配器
- 内存对齐与padding

### 内存问题排查
- 内存泄漏检测技术
- 野指针与悬垂引用
- 内存破坏与越界访问
- Valgrind工具使用

## STL库使用与原理

### 容器
- 序列容器：vector、deque、list
- 关联容器：set、map、unordered_set、unordered_map
- 各容器时间复杂度与适用场景

### 迭代器
- 迭代器类别与能力
- 迭代器失效条件
- 自定义迭代器开发

### 算法
- 排序算法：sort、stable_sort、partial_sort
- 查找算法：find、binary_search、lower_bound
- 常用数值算法：accumulate、inner_product
- 自定义谓词函数

### 适配器与仿函数
- 容器适配器：stack、queue、priority_queue
- 函数适配器：bind、function
- 常用仿函数与自定义仿函数

## 多线程与并发

### 线程管理
- std::thread创建与管理
- joinable与detach
- 线程参数传递技巧

### 互斥与同步
- mutex家族：mutex、recursive_mutex、timed_mutex
- 原子操作与memory order
- 条件变量实现线程协作
- 读写锁与共享互斥

### 高级并发模式
- 线程池设计与实现
- Future与Promise
- async与线程异步调用
- 生产者-消费者模式

### 并发陷阱
- 死锁检测与预防
- 竞态条件识别技巧
- 锁粒度与性能优化
- 无锁编程思想

---

## 实践技巧

### 代码优化
- 编译期计算与模板元编程
- 指令级并行与CPU缓存优化
- 常见性能陷阱

### 调试技术
- GDB高级调试技巧
- 静态分析工具使用
- 性能分析工具应用 