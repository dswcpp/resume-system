# 完整面试问题清单

> 基于简历内容整理，按面试流程和概率排序
> 建议：每个问题准备30-60秒回答，用STAR结构讲项目故事

---

## 一、开场与自我介绍（100%必问）

### Q1：请做一下自我介绍

**1分钟版本**：
> 面试官您好，我是段胜炜，5年C++/Qt开发经验，专注实时数据处理与设备通信领域。
>
> 目前在华乘电气负责带电检测终端T95的核心模块开发，主要成果：
> - 设计了生产者-消费者+无锁队列的数据管线，UI刷新延迟从200ms降到50ms
> - 建立模块化集成框架，新检测技术集成周期从3个月缩短到6周
>
> 之前在思行达做过营业厅物联平台和银行柜外终端，熟悉TCP/UDP、MQTT、RS485/Modbus等协议。
>
> 个人技术特点是擅长性能优化和快速对接新硬件，期望能在贵司继续深耕C++领域。

### Q2：为什么想离开现在的公司？

> 主要是寻求更大的技术挑战和成长空间：
> 1. 当前项目已进入稳定维护期，技术挑战减少
> 2. 希望接触更大规模的系统，提升架构能力
> 3. 贵司的产品/技术方向很契合我的发展规划
>
> （注意：不抱怨前公司，强调个人成长诉求）

### Q3：期望薪资多少？依据是什么？

> 期望25K左右，主要基于：
> 1. 5年C++经验，有完整的嵌入式上位机开发经验
> 2. 在性能优化方面有实战成果（无锁队列、控频刷新）
> 3. 能独立负责模块设计，有带人经验
> 4. 参考南京市场同等经验岗位薪资水平
>
> 当然具体可以根据岗位要求和职责范围协商。

---

## 二、项目深挖（100%必问，会追问细节）

### 2.1 T95带电检测终端（重点项目）

#### Q4：介绍一下T95项目，你负责什么？

> T95是多功能电力设备带电检测终端，集成红外测温、UHF局放、TEV、AE等检测技术。
>
> 我负责：
> 1. **多检测技术集成框架设计** - 统一接口规范，支持模块热插拔
> 2. **TEV检测模块开发** - 1MHz采样率脉冲采集，PRPS图谱生成
> 3. **红外模块快速集成** - 2周完成从SDK调研到功能上线
> 4. **实时数据管线重构** - 解决UI刷新卡顿问题

#### Q5：无锁队列是怎么实现的？为什么要用无锁？

> **为什么用无锁**：
> 传统mutex锁在高频数据场景下，锁竞争导致UI卡顿，profiler显示锁等待占用20%以上时间。
>
> **实现方式**：
> 采用SPSC（单生产者单消费者）无锁队列：
> ```cpp
> // 核心原理：原子变量 + 内存屏障
> std::atomic<size_t> head_{0};  // 生产者写
> std::atomic<size_t> tail_{0};  // 消费者写
> 
> bool push(const T& item) {
>     size_t head = head_.load(std::memory_order_relaxed);
>     size_t next = (head + 1) % capacity_;
>     if (next == tail_.load(std::memory_order_acquire))
>         return false;  // 队列满
>     buffer_[head] = item;
>     head_.store(next, std::memory_order_release);
>     return true;
> }
> ```
>
> **效果**：UI刷新延迟从200ms降到50ms，CPU占用降低40%

#### Q6：memory_order各个级别什么意思？

> - **relaxed**：只保证原子性，不保证顺序，性能最好
> - **acquire**：读操作，之后的读写不能重排到它之前
> - **release**：写操作，之前的读写不能重排到它之后
> - **seq_cst**：最强顺序，全局一致，性能最差
>
> **SPSC队列中的应用**：
> - 生产者用release写head，确保数据先写入buffer
> - 消费者用acquire读head，确保看到完整数据

#### Q7：模块集成周期从3个月缩短到6周，怎么做到的？

> 主要做了三件事：
>
> 1. **统一接口规范**：
> ```cpp
> class IDetectionModule {
> public:
>     virtual bool initialize() = 0;
>     virtual void startAcquisition() = 0;
>     virtual void stopAcquisition() = 0;
>     virtual DataPacket getLatestData() = 0;
>     virtual ModuleStatus getStatus() = 0;
> };
> ```
>
> 2. **标准化数据格式**：定义统一的DataPacket结构，包含时间戳、通道、采样率、原始数据
>
> 3. **配套开发文档**：新模块只需实现接口、填配置，框架自动处理通信、缓存、UI绑定
>
> **效果**：红外模块2周上线，新工程师也能独立完成模块开发

#### Q8：状态机是怎么设计的？

> 设备连接管理用状态机模式：
>
> ```
> 状态：Disconnected → Connecting → Connected → Error
> 
> 事件触发：
> - connect() → Disconnected to Connecting
> - 连接成功 → Connecting to Connected  
> - 连接超时/失败 → Connecting to Error
> - disconnect() → Connected to Disconnected
> - 通信异常 → Connected to Error
> - retry() → Error to Connecting
> ```
>
> **好处**：
> - 状态转换清晰，不会出现非法状态
> - 便于添加自动重连、超时检测等逻辑
> - 日志记录每次状态变化，便于排查问题

#### Q9：15MB/s数据处理能力是怎么测的？

> **测试方法**：
> 1. 模拟高频数据源，持续灌入不同大小的数据包
> 2. 监控队列积压情况、UI刷新帧率、CPU占用率
> 3. 逐步增加数据量直到出现瓶颈
>
> **优化前后对比**：
> | 指标 | 优化前 | 优化后 |
> |------|--------|--------|
> | 最大吞吐 | 5MB/s | 15MB/s |
> | UI帧率 | 5fps | 20fps |
> | CPU占用 | 85% | 45% |

### 2.2 营业厅智能运营管理平台

#### Q10：交叉编译环境怎么搭建的？遇到什么问题？

> **环境**：Ubuntu 20.04 + RK3399 (aarch64-linux-gnu-g++)
>
> **搭建步骤**：
> 1. 安装交叉编译工具链
> 2. 配置Qt的qmake.conf，指定target平台
> 3. 编译依赖库（OpenSSL、zlib等）
> 4. 设置sysroot和链接路径
>
> **遇到的问题**：
> - 库版本不兼容：目标板glibc版本低，需要用对应版本工具链
> - Qt插件缺失：需要手动编译移植platforms/xcb等插件
> - 字体显示问题：需要在目标板部署字体文件

#### Q11：HTTP服务器怎么实现的？

> 基于Qt的QTcpServer实现轻量级HTTP服务器：
>
> ```cpp
> void onNewConnection() {
>     QTcpSocket* socket = server_.nextPendingConnection();
>     connect(socket, &QTcpSocket::readyRead, [=]() {
>         QByteArray request = socket->readAll();
>         // 解析请求行：GET /api/devices HTTP/1.1
>         QString method = ...;
>         QString path = ...;
>         
>         // 路由分发
>         QByteArray response = router_.dispatch(method, path, body);
>         
>         // 返回响应
>         socket->write("HTTP/1.1 200 OK\r\n");
>         socket->write("Content-Type: application/json\r\n\r\n");
>         socket->write(response);
>     });
> }
> ```
>
> **支持的功能**：GET/POST、RESTful路由、JSON数据格式

#### Q12：MQTT在项目里怎么用的？

> 用于设备状态监控：
>
> **架构**：
> - Broker部署在服务器
> - 终端设备作为Client连接
>
> **Topic设计**：
> ```
> /devices/{device_id}/status  - 设备状态上报（Retain）
> /devices/{device_id}/command - 控制指令下发
> /devices/{device_id}/alert   - 告警消息
> ```
>
> **QoS选择**：
> - 普通状态：QoS 0（偶尔丢失可接受）
> - 告警消息：QoS 1（需要送达）
>
> **遗嘱消息**：设备异常断开时自动发布offline状态

### 2.3 柜外交互终端

#### Q13：响应时间从100ms优化到60ms，具体优化了哪里？

> **分析瓶颈**：
> 用profiler分析，发现主要耗时在：
> 1. 协议解析（30ms）
> 2. 数据库查询（40ms）
> 3. 序列化（20ms）
> 4. 网络传输（10ms）
>
> **优化措施**：
> 1. **协议优化**：从文本协议改为二进制协议，减少解析开销
> 2. **连接复用**：数据库连接池，避免每次新建连接
> 3. **异步化**：非关键操作放到后台线程
> 4. **缓存**：热点数据内存缓存
>
> **效果**：100ms → 60ms，提升40%

#### Q14：多线程框架怎么设计的？

> **线程模型**：
> ```
> 主线程(UI) ←→ 工作线程池 ←→ IO线程
>              ↑
>           消息队列
> ```
>
> **线程分工**：
> - 主线程：UI更新、用户交互
> - 工作线程池：业务逻辑处理
> - IO线程：网络收发、串口读写
>
> **通信机制**：
> - 线程间用消息队列通信
> - 跨线程信号槽（Qt::QueuedConnection）

---

## 三、C++核心技术（必问）

### 3.1 现代C++特性

#### Q15：你常用哪些C++11/14特性？

> **智能指针**：
> - unique_ptr管理设备连接（独占所有权）
> - shared_ptr管理共享数据（引用计数）
> - weak_ptr打破循环引用（观察者模式）
>
> **Lambda**：简化回调和信号槽
> ```cpp
> connect(timer, &QTimer::timeout, [this]() {
>     updateStatus();
> });
> ```
>
> **移动语义**：大数据缓冲区传递
> ```cpp
> DataBuffer processData(DataBuffer&& input) {
>     // 避免拷贝，直接移动
>     return std::move(result);
> }
> ```
>
> **auto/范围for**：简化代码
>
> **constexpr**：编译期计算

#### Q16：shared_ptr和unique_ptr区别？什么时候用哪个？

> | 特性 | unique_ptr | shared_ptr |
> |------|------------|------------|
> | 所有权 | 独占 | 共享 |
> | 拷贝 | 禁止 | 允许 |
> | 开销 | 无额外开销 | 引用计数（原子操作） |
> | 线程安全 | 不安全 | 引用计数线程安全 |
>
> **选择原则**：
> - 默认用unique_ptr（零开销）
> - 需要共享所有权时用shared_ptr
> - 观察者场景用weak_ptr
>
> **项目中的应用**：
> - 设备连接对象：unique_ptr（一个设备一个连接）
> - 检测模块：shared_ptr（多处引用同一模块）

#### Q17：RAII是什么？怎么用？

> RAII = Resource Acquisition Is Initialization
> 资源获取即初始化，用对象生命周期管理资源。
>
> **原理**：
> - 构造函数获取资源
> - 析构函数释放资源
> - 利用栈对象自动析构特性
>
> **项目应用**：
> ```cpp
> class SerialPortGuard {
>     QSerialPort& port_;
> public:
>     SerialPortGuard(QSerialPort& port) : port_(port) {
>         port_.open(QIODevice::ReadWrite);
>     }
>     ~SerialPortGuard() {
>         port_.close();
>     }
> };
> 
> void communicate() {
>     SerialPortGuard guard(serialPort);  // 自动打开
>     // 操作...
> }  // 离开作用域自动关闭，即使抛异常也会关闭
> ```

#### Q18：移动语义和完美转发？

> **移动语义**：
> - 解决拷贝开销问题
> - 通过"偷取"资源而非拷贝
> - std::move将左值转为右值引用
>
> ```cpp
> std::vector<int> v1 = {1,2,3};
> std::vector<int> v2 = std::move(v1);  // v1被掏空，v2获得数据
> ```
>
> **完美转发**：
> - 保持参数的左值/右值属性
> - 用于泛型编程
> ```cpp
> template<typename T>
> void wrapper(T&& arg) {
>     target(std::forward<T>(arg));  // 完美转发
> }
> ```

### 3.2 内存管理

#### Q19：new/delete和malloc/free区别？

> | 特性 | new/delete | malloc/free |
> |------|------------|-------------|
> | 类型 | C++运算符 | C函数 |
> | 构造/析构 | 调用 | 不调用 |
> | 类型安全 | 是 | 否（void*） |
> | 异常处理 | 抛bad_alloc | 返回NULL |
> | 可重载 | 是 | 否 |
>
> **使用原则**：C++中优先用new/delete，配合智能指针更好

#### Q20：虚析构函数什么时候需要？

> **需要场景**：基类指针指向派生类对象时
>
> ```cpp
> class Base {
> public:
>     virtual ~Base() {}  // 必须是虚函数
> };
> 
> class Derived : public Base {
>     Resource* res_;
> public:
>     ~Derived() { delete res_; }
> };
> 
> Base* p = new Derived();
> delete p;  // 如果~Base()不是虚函数，~Derived()不会被调用，内存泄漏
> ```
>
> **原则**：基类有虚函数，析构函数就应该是虚的

### 3.3 多线程

#### Q21：多线程怎么保证线程安全？

> **同步机制**：
> 1. **互斥锁**：std::mutex + lock_guard
> 2. **读写锁**：std::shared_mutex（多读单写）
> 3. **原子操作**：std::atomic（简单数据）
> 4. **条件变量**：std::condition_variable（等待通知）
>
> **项目中的应用**：
> - 配置数据：读写锁（读多写少）
> - 计数器：原子变量
> - 任务队列：互斥锁+条件变量
> - 高频数据：无锁队列

#### Q22：死锁怎么避免？遇到过吗？

> **死锁条件**（四个缺一不可）：
> 1. 互斥
> 2. 持有并等待
> 3. 不可剥夺
> 4. 循环等待
>
> **避免方法**：
> 1. **固定加锁顺序**：所有线程按相同顺序获取锁
> 2. **超时机制**：try_lock_for设置超时
> 3. **std::lock**：一次性获取多把锁
>
> **项目经历**：
> 曾遇到串口线程和UI线程互相等待的死锁，A等B的数据锁，B等A的状态锁。
> 解决：统一加锁顺序，先状态锁后数据锁。

---

## 四、Qt框架（高概率）

#### Q23：Qt信号槽底层原理？

> **本质**：观察者模式 + 元对象系统
>
> **实现机制**：
> 1. moc编译器解析Q_OBJECT宏，生成元对象代码
> 2. connect()在运行时建立信号-槽映射关系
> 3. emit信号时，遍历连接列表，调用槽函数
>
> **连接方式**：
> - DirectConnection：同线程直接调用
> - QueuedConnection：跨线程，放入事件队列
> - AutoConnection：自动判断（默认）

#### Q24：QThread正确用法？

> **两种方式**：
>
> **方式1：moveToThread（推荐）**
> ```cpp
> Worker* worker = new Worker();
> QThread* thread = new QThread();
> worker->moveToThread(thread);
> connect(thread, &QThread::started, worker, &Worker::doWork);
> thread->start();
> ```
>
> **方式2：继承QThread**
> ```cpp
> class MyThread : public QThread {
>     void run() override {
>         // 线程代码
>     }
> };
> ```
>
> **关键原则**：
> - 不要在子线程直接操作UI
> - 用信号槽跨线程通信

#### Q25：Qt内存管理机制？

> **父子对象机制**：
> - 设置parent的对象，parent析构时自动delete子对象
> - 不设parent的对象需手动管理
>
> ```cpp
> QWidget* parent = new QWidget();
> QPushButton* btn = new QPushButton(parent);  // parent管理
> // 不需要 delete btn，parent析构时自动删除
> ```
>
> **注意事项**：
> - 栈对象不要设parent（双重析构）
> - moveToThread后注意生命周期

---

## 五、通信协议（高概率）

#### Q26：TCP三次握手、四次挥手？

> **三次握手**：
> 1. 客户端发SYN
> 2. 服务端发SYN+ACK
> 3. 客户端发ACK
>
> **为什么三次**：确保双方都能发送和接收
>
> **四次挥手**：
> 1. 客户端发FIN
> 2. 服务端发ACK
> 3. 服务端发FIN
> 4. 客户端发ACK
>
> **为什么四次**：TCP全双工，每个方向单独关闭

#### Q27：TCP和UDP区别？什么时候用哪个？

> | TCP | UDP |
> |-----|-----|
> | 面向连接 | 无连接 |
> | 可靠 | 不可靠 |
> | 有序 | 可能乱序 |
> | 慢（握手+确认） | 快 |
>
> **项目选择**：
> - 设备控制命令：TCP（需要可靠）
> - 实时波形数据：UDP（速度优先，偶尔丢帧可接受）

#### Q28：粘包拆包怎么解决？

> **问题原因**：TCP是字节流，没有消息边界
>
> **解决方案**：
> 1. **固定长度**：每个包固定N字节
> 2. **分隔符**：用特殊字符分隔（如\n）
> 3. **长度字段**：包头带长度（推荐）
>
> **项目实现**：
> ```
> 帧格式：头(2B) + 长度(2B) + 类型(1B) + 数据(N) + CRC(2B)
> ```
> 用状态机解析，逐字节处理。

#### Q29：RS485和RS232区别？

> | 特性 | RS232 | RS485 |
> |------|-------|-------|
> | 电气特性 | 单端 | 差分 |
> | 传输距离 | 15m | 1200m |
> | 节点数 | 1对1 | 1对32 |
> | 抗干扰 | 弱 | 强 |
>
> **RS485特点**：
> - 半双工，需要方向控制（DE/RE引脚）
> - 总线拓扑，需要终端电阻
> - 常配合Modbus协议使用

#### Q30：Modbus RTU帧结构？

> ```
> 地址(1B) + 功能码(1B) + 数据(N) + CRC16(2B，低位在前)
> 
> 示例：读从站1的寄存器0x0000开始的2个
> 01 03 00 00 00 02 C4 0B
> ```
>
> **常用功能码**：
> - 0x03：读保持寄存器
> - 0x06：写单个寄存器
> - 0x10：写多个寄存器

---

## 六、设计模式（中等概率）

#### Q31：你用过哪些设计模式？

> **状态机模式**：设备连接管理
> - 状态：Disconnected/Connecting/Connected/Error
> - 好处：状态转换清晰，便于维护
>
> **生产者-消费者**：数据采集与处理解耦
> - 采集线程生产数据
> - 处理线程消费数据
> - 用队列缓冲，避免阻塞
>
> **适配器模式**：统一不同设备接口
> ```cpp
> class DeviceAdapter {
>     virtual void send(const QByteArray& data) = 0;
>     virtual QByteArray receive() = 0;
> };
> class RS485Adapter : public DeviceAdapter { ... };
> class USBAdapter : public DeviceAdapter { ... };
> ```
>
> **工厂模式**：创建检测模块实例
>
> **观察者模式**：设备状态变化通知

#### Q32：单例模式怎么实现？线程安全？

> **C++11线程安全单例**：
> ```cpp
> class Singleton {
> public:
>     static Singleton& instance() {
>         static Singleton inst;  // C++11保证线程安全
>         return inst;
>     }
> private:
>     Singleton() = default;
>     Singleton(const Singleton&) = delete;
> };
> ```
>
> **使用场景**：配置管理器、日志系统、设备管理器

---

## 七、性能优化（中等概率）

#### Q33：你怎么定位性能瓶颈？

> **工具**：
> - Qt Creator Profiler：CPU热点分析
> - Valgrind：内存泄漏检测
> - 自定义计时日志：关键路径耗时
>
> **方法**：
> 1. 先猜测可能的瓶颈点
> 2. 用profiler验证
> 3. 针对性优化
> 4. 对比优化前后数据
>
> **项目案例**：
> T95项目发现UI卡顿，profiler显示锁等待占20%，改用无锁队列后降到2%。

#### Q34：有哪些常用的优化手段？

> **CPU优化**：
> - 减少锁竞争（无锁队列、读写锁）
> - 避免频繁内存分配（对象池）
> - 批量处理（减少系统调用）
>
> **内存优化**：
> - 对象复用
> - 内存池
> - 避免不必要的拷贝（移动语义）
>
> **IO优化**：
> - 异步IO
> - 缓冲区合理设置
> - 批量读写

---

## 八、行为面试（必问）

#### Q35：遇到过最难的技术问题？怎么解决的？

> **问题**：T95项目UI刷新卡顿，用户反馈体验差
>
> **分析**：
> - profiler显示锁等待时间占20%
> - 数据采集线程和UI线程频繁争抢互斥锁
>
> **解决**：
> 1. 引入SPSC无锁队列替代加锁队列
> 2. 实现控频刷新策略，限制UI更新频率
> 3. 数据批量处理，减少线程交互次数
>
> **结果**：UI延迟200ms→50ms，CPU占用降低40%

#### Q36：有没有做错过技术决策？

> **经历**：
> 早期项目中为了"灵活性"设计了过度复杂的配置系统，支持各种动态配置。
>
> **结果**：
> - 配置文件难以维护
> - 排查问题时无法确定实际生效的配置
> - 新人上手困难
>
> **教训**：
> - YAGNI原则：不要过度设计
> - 简单优先：够用就行
> - 现在我会先做最简单的实现，有需求再扩展

#### Q37：怎么带新人的？

> **方法**：
> 1. **任务拆解**：把复杂任务拆成小任务，让新人有成就感
> 2. **代码Review**：每次提交我都review，指出问题和改进点
> 3. **技术分享**：组织"状态机设计"、"性能优化"等主题分享
> 4. **文档沉淀**：让新人写开发笔记，我来审核补充
>
> **效果**：2名初级工程师3个月后能独立完成模块开发

---

## 九、反问环节（必准备）

### 技术相关
- 团队目前C++主要用在什么场景？
- 项目的技术栈和架构是怎样的？
- 团队遇到的最大技术挑战是什么？

### 成长相关
- 新人前三个月最希望我重点补什么技能？
- 团队有code review机制吗？
- 有技术分享或培训吗？

### 团队文化
- 团队的工作节奏是怎样的？
- 产品的发展方向是什么？

---

## 十、快速自检清单

### ✅ 必须熟练回答
- [ ] 自我介绍（1分钟）
- [ ] T95项目（无锁队列、模块集成、状态机）
- [ ] 智能指针（shared/unique/weak区别）
- [ ] 多线程安全（锁、原子、无锁）
- [ ] TCP/UDP区别
- [ ] Qt信号槽原理

### ✅ 需要准备的故事
- [ ] 最难的技术问题（无锁队列优化）
- [ ] 最有成就感的项目（T95集成框架）
- [ ] 技术决策错误（过度设计）
- [ ] 带新人经历

### ✅ 数字要记住
- [ ] 5年C++经验
- [ ] UI延迟200ms→50ms
- [ ] CPU占用降低40%
- [ ] 集成周期3个月→6周
- [ ] 响应时间100ms→60ms
- [ ] 定位精度±0.05mm
- [ ] 系统稳定性99.9%
