# 面试问题全清单

> 基于简历内容整理，覆盖面试官可能问的所有问题。
> 建议：每个问题都准备好答案，特别是标注 ⚠️ 的高频问题。

---

## 一、开场问题

### 1.1 自我介绍

⚠️ **请做一下自我介绍**

准备要点：
- 控制在2-3分钟
- 结构：基本信息 → 技术栈 → 核心项目 → 求职意向
- 突出亮点，不要复述简历

参考模板：
```
我叫段胜炜，5年C++开发经验，目前在南京华乘电气做嵌入式应用开发。

技术上主要做Qt/C++开发，擅长实时数据处理和设备通信。
比如我们做的T95带电检测终端，我负责核心数据处理模块，
用无锁队列把UI延迟从200ms优化到50ms。

之前在思行达做过柜外交互终端，用户量上万，主要负责Windows中转服务开发。
再之前在威力固做PCB喷墨设备，用Halcon和OpenCV做图像处理。

现在想找一个能深入做技术的机会，期望薪资25K。
```

### 1.2 离职原因

⚠️ **你为什么从上一家公司离职？**（会问每一家）

| 公司 | 时间 | 建议回答 |
|------|------|----------|
| 威力固 | 1.5年 | "公司主要做PCB设备，技术栈比较固定，想接触更多类型的项目，学习更多东西" |
| 思行达 | 1年 | "项目结束后公司业务调整，正好有华乘的机会，技术方向更匹配我的发展" |
| 华乘（现） | 2年 | "产品已经稳定，想寻找新的技术挑战"（不要说负面的） |

**禁忌回答**：
- ❌ "钱太少" → 显得只看钱
- ❌ "和领导不合" → 显得难相处
- ❌ "公司不行" → 显得负面
- ❌ "太累了" → 显得不能吃苦

### 1.3 职业规划

⚠️ **你的职业规划是什么？**

```
短期（1-2年）：深入某个技术方向，比如高性能数据处理或者嵌入式系统架构，
              成为这个领域的技术专家。
              
中期（3-5年）：能够独立负责一个产品或者子系统的技术架构，
              带领小团队完成复杂项目。
              
长期：保持技术敏感度，根据行业发展选择技术管理或者架构师方向。
```

### 1.4 期望薪资

⚠️ **你的期望薪资是多少？**

```
我的期望是25K。

这个数字是基于我5年的工作经验、目前的技术能力、
以及南京市场的薪资水平综合考虑的。

当然，具体数字可以根据岗位要求和公司情况商量。
我更看重的是技术发展空间和团队氛围。
```

**追问：你现在多少钱？**
```
目前税前XX（如实说，但可以包含年终奖均摊）。
这次跳槽期望有20-30%的涨幅，25K是我比较满意的数字。
```

---

## 二、技术基础问题

### 2.1 C++基础

#### 智能指针（简历提到）

⚠️ **shared_ptr的引用计数是怎么实现的？线程安全吗？**

```
引用计数实现：
- 每个shared_ptr内部有两个指针：一个指向对象，一个指向控制块
- 控制块里存着强引用计数和弱引用计数
- 拷贝shared_ptr时，强引用计数+1
- 析构时，强引用计数-1，减到0时删除对象

线程安全：
- 引用计数的增减是原子操作，线程安全
- 但是对象本身的访问不是线程安全的
- 多线程同时读写同一个shared_ptr对象也不是线程安全的
```

**shared_ptr和unique_ptr的区别？什么时候用哪个？**

```
unique_ptr：
- 独占所有权，不能拷贝只能移动
- 零开销，和裸指针一样快
- 用于明确单一所有者的场景

shared_ptr：
- 共享所有权，引用计数
- 有额外开销（控制块、原子操作）
- 用于需要多个地方共享对象的场景

我的项目里大部分用unique_ptr，只有数据包在多个模块间传递时用shared_ptr。
```

**weak_ptr是干什么用的？**

```
解决shared_ptr循环引用问题。

比如A持有B的shared_ptr，B也持有A的shared_ptr，
两个引用计数都不会归零，内存泄漏。

解决方案：让其中一方用weak_ptr。
weak_ptr不增加强引用计数，使用前要lock()转成shared_ptr。
```

#### 移动语义（简历提到）

**什么是移动语义？为什么需要它？**

```
移动语义允许"偷"走临时对象的资源，而不是拷贝。

比如返回一个大vector：
- 没有移动语义：拷贝整个vector，开销大
- 有移动语义：把内部指针偷过来，原对象置空，几乎零开销

实现方式：
- 移动构造函数：ClassName(ClassName&& other)
- 移动赋值运算符：operator=(ClassName&& other)
```

**std::move是什么？它真的移动了吗？**

```
std::move本身不移动任何东西，它只是把左值转成右值引用。

真正的移动发生在移动构造函数或移动赋值运算符里。

std::move只是告诉编译器："这个对象我不要了，你可以偷它的资源"。
```

**什么是完美转发？**

```
完美转发是指在模板函数中，把参数原封不动地转发给另一个函数。
保持参数的左值/右值属性。

template<typename T>
void wrapper(T&& arg) {
    target(std::forward<T>(arg));  // 完美转发
}

用途：写通用的包装函数、工厂函数等。
```

#### RAII（简历提到）

**什么是RAII？举个例子？**

```
RAII = Resource Acquisition Is Initialization
资源获取即初始化。

核心思想：
- 构造函数里获取资源
- 析构函数里释放资源
- 利用C++的确定性析构，保证资源一定会被释放

例子：
- 智能指针管理内存
- lock_guard管理互斥锁
- fstream管理文件句柄
- 我写的串口类，构造时打开，析构时关闭
```

#### STL相关

**vector和list的区别？什么时候用哪个？**

```
vector：
- 连续内存，随机访问O(1)
- 尾部插入O(1)，中间插入O(n)
- 缓存友好

list：
- 双向链表，随机访问O(n)
- 任意位置插入O(1)（如果已有迭代器）
- 缓存不友好

实际项目中90%用vector，除非需要频繁在中间插入删除。
```

**map和unordered_map的区别？**

```
map：
- 红黑树实现，有序
- 查找/插入O(log n)

unordered_map：
- 哈希表实现，无序
- 查找/插入平均O(1)，最坏O(n)

选择：
- 需要有序 → map
- 只需要快速查找 → unordered_map
- 键是自定义类型，没有hash函数 → map更方便
```

### 2.2 多线程基础

#### 线程同步

⚠️ **mutex和lock_guard的区别？**

```
mutex是互斥锁本身，需要手动lock()和unlock()。

lock_guard是RAII封装：
- 构造时自动lock
- 析构时自动unlock
- 避免忘记unlock或异常时未unlock

还有unique_lock，比lock_guard更灵活，可以手动解锁、延迟加锁。
```

**什么是死锁？怎么避免？**

```
死锁：两个线程互相等待对方持有的锁。

避免方法：
1. 固定加锁顺序：所有线程按相同顺序加锁
2. std::lock：同时锁多个mutex
3. try_lock：尝试加锁，失败就放弃
4. 超时机制：等待一定时间后放弃
5. 减少锁粒度：尽量缩小临界区
```

**condition_variable怎么用？**

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

// 等待方
{
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; });  // 等待条件满足
    // 处理数据...
}

// 通知方
{
    std::lock_guard<std::mutex> lock(mtx);
    ready = true;
}
cv.notify_one();  // 唤醒一个等待线程
```

#### 原子操作（简历提到无锁队列）

⚠️ **什么是memory_order？为什么无锁队列要用它？**

```
memory_order控制内存操作的可见性顺序。

常用的：
- memory_order_relaxed：最宽松，只保证原子性
- memory_order_acquire：读操作，能看到之前的release写
- memory_order_release：写操作，之后的acquire能看到
- memory_order_seq_cst：最严格，全局顺序一致

SPSC无锁队列里：
- 写head用release：让消费者能看到写入的数据
- 读head用acquire：能看到生产者写的数据
- 读写自己的变量用relaxed：不需要同步

选错了会导致数据竞争或者可见性问题。
```

### 2.3 Qt基础

#### 信号槽（简历提到）

⚠️ **Qt信号槽的底层原理是什么？**

```
信号槽本质是观察者模式 + 元对象系统。

原理：
1. moc（元对象编译器）扫描Q_OBJECT宏，生成元信息
2. 信号其实是函数声明，moc生成实现
3. connect时，把槽函数指针存到发送者的连接列表里
4. emit信号时，遍历连接列表，调用每个槽函数

跨线程时：
- 默认是Qt::AutoConnection
- 如果接收者在不同线程，会把调用包装成事件，投递到接收者的事件队列
- 接收者线程的事件循环会处理这个事件，调用槽函数
```

**Qt::DirectConnection和Qt::QueuedConnection的区别？**

```
DirectConnection：
- 直接调用，和普通函数调用一样
- 在发送者线程执行
- 同线程默认用这个

QueuedConnection：
- 把调用包装成事件，投递到接收者的事件队列
- 在接收者线程执行
- 跨线程默认用这个

还有BlockingQueuedConnection：
- 跨线程，但发送者会阻塞等待槽函数执行完
- 小心死锁
```

#### QThread

⚠️ **QThread的正确用法是什么？**

```
两种方式：

方式一：moveToThread（推荐）
Worker* worker = new Worker;
QThread* thread = new QThread;
worker->moveToThread(thread);
connect(thread, &QThread::started, worker, &Worker::doWork);
thread->start();

方式二：继承QThread，重写run()
class MyThread : public QThread {
    void run() override {
        // 在新线程执行
    }
};

推荐方式一，因为：
- 对象的所有槽函数都在新线程执行
- 更符合Qt的事件驱动模型
- 方式二只有run()在新线程，槽函数还是在主线程
```

#### Model/View

**Qt的Model/View架构是什么？**

```
MVC模式的变体，把数据和显示分离。

三个组件：
- Model：数据源，提供数据访问接口
- View：显示组件，负责渲染
- Delegate：负责编辑和自定义渲染

好处：
- 同一份数据可以被多个View显示
- 修改显示逻辑不影响数据
- 大数据量时只渲染可见部分，性能好

我用过QTableView + 自定义Model显示检测数据，
数据量大但只渲染屏幕上的行，很流畅。
```

### 2.4 网络编程

#### TCP/UDP

**TCP和UDP的区别？**

```
TCP：
- 面向连接，三次握手
- 可靠传输，有确认重传
- 有序，数据按发送顺序到达
- 适合要求可靠的场景：HTTP、文件传输

UDP：
- 无连接，直接发
- 不可靠，可能丢包
- 无序，先发的可能后到
- 适合实时性要求高的场景：视频、游戏

我们设备通信用TCP，因为控制命令不能丢。
```

**三次握手的过程？为什么是三次？**

```
过程：
1. 客户端 → 服务端：SYN，seq=x
2. 服务端 → 客户端：SYN+ACK，seq=y，ack=x+1
3. 客户端 → 服务端：ACK，ack=y+1

为什么三次：
- 两次不够：服务端不知道客户端能不能收到
- 四次浪费：三次已经能确认双向通信能力

三次的作用：
- 第一次：服务端知道客户端能发
- 第二次：客户端知道服务端能收能发
- 第三次：服务端知道客户端能收
```

#### select/epoll（简历提到）

**select和epoll的区别？**

```
select：
- 有文件描述符数量限制（1024）
- 每次调用都要把fd集合从用户态拷贝到内核态
- 返回后需要遍历所有fd找到就绪的
- 时间复杂度O(n)

epoll：
- 没有数量限制
- 只需要注册一次，不用每次拷贝
- 返回的就是就绪的fd列表
- 时间复杂度O(1)

大量连接时epoll性能好很多。
```

**epoll的ET和LT模式区别？**

```
LT（水平触发，默认）：
- 只要有数据可读，就一直通知
- 简单，不容易漏数据
- 可能通知多次

ET（边缘触发）：
- 只在状态变化时通知一次
- 必须一次读完所有数据，否则不会再通知
- 效率高，但编程复杂
- 必须用非阻塞IO
```

### 2.5 设备通信

#### 串口/RS485（简历提到）

**串口通信需要配置哪些参数？**

```
波特率：9600、115200等，双方必须一致
数据位：通常8位
停止位：1位或2位
校验位：无校验、奇校验、偶校验
流控：无、硬件流控、软件流控

我们一般用：115200, 8N1（8数据位，无校验，1停止位）
```

**RS485和RS232的区别？**

```
RS232：
- 点对点通信
- 传输距离短（15米）
- 全双工

RS485：
- 总线结构，支持多设备
- 传输距离长（1200米）
- 半双工，需要收发切换
- 差分信号，抗干扰强

我们项目里一个主机带多个传感器就用RS485。
```

#### Modbus（简历提到）

**Modbus协议的基本结构？**

```
Modbus RTU帧格式：
| 从站地址(1B) | 功能码(1B) | 数据(nB) | CRC(2B) |

常用功能码：
- 0x01：读线圈
- 0x03：读保持寄存器
- 0x06：写单个寄存器
- 0x10：写多个寄存器

我写过Modbus解析，就是按这个格式解析，校验CRC。
```

#### MQTT（简历提到）

**MQTT的QoS等级是什么？**

```
QoS 0：最多一次
- 发完就不管了，可能丢失
- 适合不重要的传感器数据

QoS 1：至少一次
- 确保到达，但可能重复
- 有ACK确认机制
- 适合大多数场景

QoS 2：恰好一次
- 确保不丢不重
- 四次握手，开销大
- 适合计费等严格场景

我们设备状态用QoS 1，控制命令用QoS 2。
```

---

## 三、项目深挖问题

### 3.1 T95带电检测终端

#### 整体架构

⚠️ **这个项目的整体架构是什么样的？**

```
整体分三层：

1. 数据采集层
   - 各检测模块（红外、UHF、TEV、AE）的驱动和数据采集
   - 每个模块一个采集线程
   - 数据通过无锁队列传给处理层

2. 数据处理层
   - 数据解析、格式转换
   - 算法处理（FFT、PRPS等）
   - 结果通过信号槽传给UI

3. UI展示层
   - Qt GUI，多页面切换
   - 实时波形、图谱显示
   - 控频刷新，30Hz

模块之间通过接口解耦，新模块只需要实现接口就能接入。
```

#### 无锁队列

⚠️ **为什么用无锁队列？不用mutex行吗？**

```
背景：
数据采集线程1000Hz产生数据，UI线程30Hz消费。
采集不能被阻塞，否则会丢数据。

为什么不用mutex：
- mutex加锁解锁有开销
- 如果UI处理慢，采集线程会被阻塞
- 高频场景下锁竞争严重

无锁队列的好处：
- 生产者永远不阻塞（队列满时可以丢弃旧数据）
- 没有锁开销
- 延迟更稳定

当然也有代价：只适合SPSC场景，多生产者就需要MPMC或者其他方案。
```

⚠️ **200ms延迟是怎么测出来的？**

```
测量方法：
1. 采集线程打时间戳到数据包里
2. UI线程收到数据后，算当前时间和时间戳的差值
3. 每隔1秒输出一次平均延迟到日志

优化前测了一周的数据，平均200ms左右，峰值能到500ms。
优化后平均50ms，峰值不超过100ms。
```

**CPU占用40%是怎么测的？**

```
用Qt Creator的性能分析工具，采样CPU占用。

主要发现UI线程占用高：
- 刷新太频繁（每来一帧数据就刷新）
- 每次刷新都重绘整个波形控件

优化后：
- 控频刷新，每33ms刷新一次
- 增量更新，只更新变化的部分

CPU占用从45%降到18%左右。
```

#### 状态机

⚠️ **状态机有几个状态？状态转换图能画出来吗？**

```
红外模块连接状态机，5个状态：

Disconnected（断开）
    ↓ UsbAttached
Connecting（连接中）
    ↓ EnumSuccess     ↘ Timeout/UsbDetached
Initializing（初始化中）   → Disconnected
    ↓ InitSuccess     ↘ InitFailed
Ready（就绪）              → Error（异常）
    ↓ UsbDetached           ↓ Reset
Disconnected              Disconnected

每个状态有明确的进入条件和退出动作。
比如进入Connecting时启动超时定时器，进入Ready时开始数据采集。
```

**为什么要用状态机？原来的代码有什么问题？**

```
原来的代码：
- 用一堆bool标志：isConnected、isInitializing、isError
- 状态判断散落在各处
- 某些状态组合没考虑到，会崩溃

状态机的好处：
- 状态转换逻辑集中在一个地方
- 每个状态能做什么、不能做什么很清晰
- 新同事看状态图就能理解
- 不会出现非法状态组合
```

#### 协议可靠性

**CRC校验是怎么实现的？**

```
用的CRC-16/MODBUS：
- 多项式：0x8005
- 初始值：0xFFFF
- 结果异或：0x0000

实现方式：查表法，比逐位计算快。
预先计算256个字节对应的CRC值存到表里，
运行时查表累加。
```

**超时重试机制是怎么设计的？**

```
发送命令时：
1. 生成序列号，存到待确认队列
2. 记录发送时间
3. 启动100ms定时器检查超时

定时器回调：
1. 检查待确认队列
2. 超过500ms没响应的，重发，重试次数+1
3. 重试3次失败，上报错误

收到响应时：
1. 根据序列号从待确认队列移除
2. 触发成功回调

为什么500ms？根据实测，正常响应50-100ms，500ms留足余量。
```

### 3.2 柜外交互终端

**这个项目你负责什么？**

```
我负责Windows中转服务模块。

中转服务的作用：
- 终端设备（柜外机）通过USB连到Windows电脑
- 电脑上的服务把数据转发到后台服务器
- 同时把后台的响应转回给终端

我做的工作：
1. 设计服务架构，多线程处理USB和网络
2. 实现协议转换，终端协议和后台协议不一样
3. 实现断线重连、消息持久化
4. 开发日志和监控模块
```

**用户量10000+，你们怎么保证稳定性？**

```
几个方面：

1. 异常处理
   - 所有可能失败的操作都有try-catch
   - 网络断开自动重连
   - 消息发送失败会存本地，恢复后重发

2. 监控告警
   - 关键操作记日志
   - 异常次数超阈值发邮件告警
   - 每天有巡检脚本检查服务状态

3. 灰度发布
   - 新版本先在几个网点试运行
   - 稳定后再全量推送

实际运行稳定性99.9%以上。
```

### 3.3 营业厅智能运营管理平台

**交叉编译环境搭建有什么坑？**

```
几个常见的坑：

1. 工具链版本问题
   - RK3399是aarch64架构
   - 要用aarch64-linux-gnu-g++交叉编译器
   - 编译器版本要和目标系统的glibc版本匹配

2. Qt交叉编译
   - 要单独编译一份Qt for ARM
   - qmake的mkspec要指定对
   - 依赖库（如openssl）也要交叉编译

3. 库移植
   - 编译好的程序要把依赖的.so一起拷到目标机
   - 用ldd检查依赖
   - 有些系统库目标机有，不需要拷

我当时踩了不少坑，后来写了个文档记录了所有步骤。
```

**HTTP服务器为什么自己写，不用现成的？**

```
原因：
1. 嵌入式平台资源受限，nginx这些太重
2. 我们只需要简单的REST API，不需要完整的HTTP服务器
3. 方便定制，比如加设备认证逻辑

实现：
- 基于socket自己解析HTTP协议
- 支持GET/POST
- 事件驱动，单线程处理多连接
- 代码量就几百行
```

### 3.4 PCB喷墨设备

**Mark点识别算法是怎么实现的？**

```
用Halcon实现的，大致流程：

1. 图像预处理
   - 灰度化
   - 高斯滤波去噪
   - 对比度增强

2. 特征提取
   - 二值化
   - 边缘检测
   - 圆检测（Mark点是圆形的）

3. 精确定位
   - 亚像素边缘拟合
   - 圆心坐标计算
   - 坐标转换（像素→物理坐标）

精度达到±0.05mm，主要是靠亚像素定位和相机标定。
```

---

## 四、行为面试问题

### 4.1 团队协作

⚠️ **你带的2个初级工程师，你是怎么带的？**

```
主要几个方面：

1. 任务分配
   - 根据他们的能力分配难度合适的任务
   - 先给简单的模块练手，再慢慢加难度
   - 复杂任务我先定好方案，他们实现

2. 代码审核
   - 每次提交我都会review
   - 不只是找bug，也会指出可以改进的地方
   - 好的地方也会表扬

3. 技术指导
   - 遇到问题先让他们自己想
   - 想不出来再给提示，而不是直接给答案
   - 定期分享一些技术点

效果：其中一个同事现在已经能独立负责模块了。
```

**团队里有人和你意见不同怎么处理？**

```
最近一次是关于状态机实现方式。

同事建议用Qt的QStateMachine，我觉得自己实现更轻量。

我的处理：
1. 先听他的理由：QStateMachine功能强大，代码规范
2. 说明我的考虑：我们场景简单，QStateMachine有些重
3. 让数据说话：各写了一个demo，比较代码量和性能
4. 最后决定：自己实现，但参考QStateMachine的命名规范

结果他也认可这个方案。关键是要有理有据，不是谁职级高听谁的。
```

### 4.2 问题解决

⚠️ **遇到一个难题解决不了怎么办？**

```
分几步：

1. 先自己尝试（不超过2小时）
   - 看文档、搜资料
   - 打日志、加断点定位
   - 写最小复现demo

2. 如果还不行，找人帮忙
   - 先整理清楚问题是什么、试了哪些方案
   - 问同事或者在技术群里问
   - 不要问"为什么不行"，要问"我试了ABC，现象是XYZ，可能是什么原因"

3. 如果还不行，找上级
   - 说明影响范围和时间
   - 让他帮忙协调资源或者做决策

关键是不要卡太久，也不要一上来就问别人。
```

**说一个你解决的最有挑战的问题？**

```
T95的UI卡顿问题。

挑战点：
- 现场反馈卡，但开发环境复现不了
- 卡顿是偶发的，不是每次都有
- 涉及多个线程，不好定位

解决过程：
1. 加详细日志，让现场跑了一周收集数据
2. 分析日志发现规律：同时开多个检测模块时容易卡
3. 用日志算延迟，发现数据从采集到显示有200-500ms
4. 定位到原因：多个模块同时写数据，锁竞争严重
5. 方案：无锁队列 + 控频刷新
6. 测试验证：延迟降到50ms，再没收到卡顿反馈

这个问题让我学到：复现不了的问题靠日志。
```

### 4.3 学习能力

⚠️ **你怎么学习新技术？**

```
我学红外模块的例子：

第1-2天：通读文档
- 先看整体架构，不纠结细节
- 标记出关键的API

第3-4天：跑通demo
- 用最简单的代码把核心功能跑通
- 这一步最重要，很多问题这时候就暴露了

第5天：深入理解
- 回过头再看文档里之前跳过的部分
- 理解API的参数含义、错误处理

之后：集成到项目
- 按项目规范封装
- 处理边界情况
- 写文档

这个流程让我2周就能接入一个新模块。
```

---

## 五、反问环节

### 应该问的

1. **团队情况**
   - 团队多少人？怎么分工的？
   - 我会负责哪块业务？

2. **技术栈**
   - 主要用什么技术栈？
   - 有没有技术债务需要处理？

3. **发展空间**
   - 公司对技术人员的培养路径是怎样的？
   - 有没有技术分享或学习的机制？

4. **项目情况**
   - 目前在做什么项目？处于什么阶段？
   - 最大的技术挑战是什么？

### 不应该问的

- ❌ 加班多吗？（显得怕吃苦）
- ❌ 多久能涨工资？（显得只看钱）
- ❌ 五险一金怎么交？（HR会说，面试官不管这个）
- ❌ 什么都不问（显得没兴趣）

---

## 六、薪资谈判

### 常见问题

**你现在薪资多少？**

```
如实说，但可以包含所有收入：
"税前XX，加上年终奖均摊大概XX/月"
```

**你的期望薪资是多少？**

```
"期望25K。这是根据我的经验、能力和市场情况综合考虑的。
当然具体可以商量，我更看重发展空间。"
```

**25K有点高，我们预算是22K**

```
几种回应：

1. 坚持："25K是我的底线，这个薪资在市场上是合理的"

2. 妥协："如果其他方面（发展空间、技术方向）很匹配，
        22K也可以接受，但希望试用期后有调整空间"

3. 折中："能不能在23-24K？或者补充一些其他福利？"

选哪种取决于你有多想要这个offer。
```

---

## 附录：问题速查表

| 类别 | 高频问题 |
|------|----------|
| 开场 | 自我介绍、离职原因、职业规划、期望薪资 |
| C++基础 | 智能指针、移动语义、RAII、STL |
| 多线程 | mutex/lock_guard、死锁、condition_variable、memory_order |
| Qt | 信号槽原理、QThread用法、Model/View |
| 网络 | TCP/UDP区别、三次握手、select/epoll |
| 设备通信 | 串口参数、RS485/232区别、Modbus、MQTT QoS |
| T95项目 | 架构设计、无锁队列、状态机、协议可靠性 |
| 行为面试 | 带人经验、意见分歧、难题解决、学习方法 |
