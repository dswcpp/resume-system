# 简历技术点面试故事

> 面试官看到简历会问："这个具体怎么做的？" 需要用 **STAR法则** 讲清楚：
> - **S**ituation（背景）：什么项目、什么场景
> - **T**ask（任务）：要解决什么问题
> - **A**ction（行动）：你具体做了什么
> - **R**esult（结果）：效果怎么样

---

## 故事一：SPSC无锁队列优化UI延迟

### 面试官可能的问法

- "简历上写的无锁队列是怎么回事？"
- "你们为什么要用无锁队列？"
- "UI延迟从200ms降到50ms，具体怎么做到的？"

### 完整故事

#### 背景（Situation）

T95是一个电力检测手持终端，要实时显示多种传感器数据——红外图像、UHF频谱、TEV波形。数据采集线程在后台高速运行，UI线程负责刷新显示。

#### 问题（Task）

上线初期用户反馈界面卡顿，特别是切换检测模式时，UI会卡住1-2秒。我用日志埋点分析后发现：

1. **数据线程和UI线程用`QMutex`同步**，锁竞争严重
2. **UI线程频繁刷新**，每来一帧数据就刷一次，但数据采集速率是1000Hz，屏幕才60Hz
3. **数据拷贝开销大**，每次刷新都要深拷贝整个数据包

#### 方案（Action）

我主导了数据管线重构，分三步：

**第一步：引入SPSC无锁队列**

```cpp
// 单生产者单消费者场景，用无锁队列替代互斥锁
template<typename T, size_t Capacity>
class SPSCQueue {
    std::array<T, Capacity> buffer_;
    std::atomic<size_t> head_{0};  // 生产者写
    std::atomic<size_t> tail_{0};  // 消费者读
    
public:
    bool push(const T& item) {
        size_t head = head_.load(std::memory_order_relaxed);
        size_t next = (head + 1) % Capacity;
        if (next == tail_.load(std::memory_order_acquire))
            return false;  // 队列满
        buffer_[head] = item;
        head_.store(next, std::memory_order_release);
        return true;
    }
    
    bool pop(T& item) {
        size_t tail = tail_.load(std::memory_order_relaxed);
        if (tail == head_.load(std::memory_order_acquire))
            return false;  // 队列空
        item = buffer_[tail];
        tail_.store((tail + 1) % Capacity, std::memory_order_release);
        return true;
    }
};
```

为什么选SPSC而不是MPMC？因为我们场景是**一个采集线程写、一个UI线程读**，SPSC实现简单、性能最好。

**第二步：控频刷新**

UI不再被动响应数据到来，而是主动按固定频率（30Hz）拉取数据：

```cpp
// UI线程定时器，每33ms触发一次
void onRefreshTimer() {
    DataPacket packet;
    // 只取最新的一帧，中间的丢弃
    while (dataQueue_.pop(packet)) {
        latestPacket_ = std::move(packet);
    }
    if (latestPacket_.isValid()) {
        updateDisplay(latestPacket_);
    }
}
```

**第三步：减少数据拷贝**

用`std::shared_ptr`共享数据，避免深拷贝：

```cpp
using DataPacketPtr = std::shared_ptr<DataPacket>;
SPSCQueue<DataPacketPtr, 64> dataQueue_;
```

#### 结果（Result）

| 指标 | 优化前 | 优化后 |
|------|--------|--------|
| UI刷新延迟 | 200ms | 50ms |
| CPU占用（UI线程） | 45% | 18% |
| 切换模式卡顿 | 1-2秒 | 无感知 |

### 追问准备

**Q：为什么不用Qt的信号槽？**

> 信号槽底层也是队列，但它是通用设计，有类型擦除和动态分配开销。我们场景固定、性能敏感，自己实现SPSC更可控。而且信号槽是多生产者安全的，我们不需要。

**Q：无锁队列会丢数据吗？**

> 会。队列满了push会失败。但我们的场景允许丢帧——采集1000Hz，显示30Hz，中间大部分帧本来就要丢。关键是保证**最新数据能显示**，而不是每帧都显示。

**Q：memory_order为什么这么写？**

> - `relaxed`：读自己的变量，不需要同步
> - `acquire`：读对方的变量，要看到对方之前的写
> - `release`：写完后让对方能看到
> 
> 这是SPSC的标准写法，比`seq_cst`性能好，但要确保只有一个生产者一个消费者。

**Q：为什么队列大小是64？**

> 根据实际测试调的。太小容易溢出，太大浪费内存。64帧≈2秒的数据缓冲，够UI线程处理了。

---

## 故事二：状态机管理设备连接

### 面试官可能的问法

- "状态机是怎么用的？"
- "红外模块连接管理具体怎么实现？"
- "为什么要用状态机？"

### 完整故事

#### 背景（Situation）

T95要对接一个红外热成像模块，通过USB连接。这个模块有个特点：连接不太稳定，USB偶尔会断开重连，而且初始化需要几秒钟。

#### 问题（Task）

最初的代码是这样的：

```cpp
// 问题代码：状态判断散落各处
void onDataReceived(Data data) {
    if (!isConnected) return;
    if (isInitializing) return;
    // 处理数据...
}

void onDisconnected() {
    isConnected = false;
    // 停止显示？还是显示上一帧？逻辑不清晰
}
```

问题：
1. 状态标志散落各处，`isConnected`、`isInitializing`、`isError`组合起来有8种情况，容易漏
2. 断开重连时偶尔崩溃，因为某些状态组合没考虑到
3. 新同事接手代码时经常问"这个状态下能不能调这个函数"

#### 方案（Action）

我用状态机重构了连接管理：

**定义状态和事件**

```cpp
enum class DeviceState {
    Disconnected,   // 未连接
    Connecting,     // 连接中（USB枚举）
    Initializing,   // 初始化中（下发配置）
    Ready,          // 就绪，可以采集
    Error           // 异常
};

enum class DeviceEvent {
    Connect,        // 用户点击连接
    UsbAttached,    // USB设备插入
    UsbDetached,    // USB设备拔出
    InitSuccess,    // 初始化成功
    InitFailed,     // 初始化失败
    Timeout,        // 超时
    Reset           // 用户重置
};
```

**状态转换表**

```cpp
// 状态转换逻辑集中管理
void handleEvent(DeviceEvent event) {
    switch (state_) {
    case DeviceState::Disconnected:
        if (event == DeviceEvent::UsbAttached) {
            state_ = DeviceState::Connecting;
            startEnumeration();
        }
        break;
        
    case DeviceState::Connecting:
        if (event == DeviceEvent::InitSuccess) {
            state_ = DeviceState::Initializing;
            sendInitCommands();
        } else if (event == DeviceEvent::UsbDetached || 
                   event == DeviceEvent::Timeout) {
            state_ = DeviceState::Disconnected;
            notifyUser("连接失败");
        }
        break;
        
    case DeviceState::Initializing:
        if (event == DeviceEvent::InitSuccess) {
            state_ = DeviceState::Ready;
            startDataAcquisition();
        } else if (event == DeviceEvent::InitFailed) {
            state_ = DeviceState::Error;
            notifyUser("初始化失败");
        }
        break;
        
    case DeviceState::Ready:
        if (event == DeviceEvent::UsbDetached) {
            state_ = DeviceState::Disconnected;
            stopDataAcquisition();
            notifyUser("设备已断开");
        }
        break;
        
    case DeviceState::Error:
        if (event == DeviceEvent::Reset) {
            state_ = DeviceState::Disconnected;
        }
        break;
    }
    
    updateUI();  // 统一更新界面状态
}
```

**状态图文档**

```
[Disconnected] --UsbAttached--> [Connecting]
[Connecting] --InitSuccess--> [Initializing]
[Connecting] --Timeout/UsbDetached--> [Disconnected]
[Initializing] --InitSuccess--> [Ready]
[Initializing] --InitFailed--> [Error]
[Ready] --UsbDetached--> [Disconnected]
[Error] --Reset--> [Disconnected]
```

#### 结果（Result）

1. **Bug减少**：重构后3个月内没有再出现连接相关的崩溃
2. **代码清晰**：新同事看状态图就能理解逻辑
3. **易于扩展**：后来加"固件升级"状态，只需要加一个状态和几条转换

### 追问准备

**Q：为什么不用Qt的QStateMachine？**

> 考虑过，但QStateMachine比较重，适合复杂的UI状态管理。我们这个场景状态不多（5个），自己写更轻量、更可控。而且调试时直接打印枚举值就能看状态，QStateMachine还得去查state name。

**Q：状态转换是线程安全的吗？**

> 所有事件都通过Qt的信号槽投递到主线程处理，所以状态机本身是单线程的，不需要加锁。USB事件来自系统回调，我用`QMetaObject::invokeMethod`转到主线程。

**Q：怎么处理超时？**

> 每次进入需要等待的状态（Connecting、Initializing）就启动一个`QTimer`，超时触发Timeout事件。进入下一个状态时取消定时器。

---

## 故事三：协议解析可靠性优化

### 面试官可能的问法

- "CRC校验、重试机制具体怎么做的？"
- "通信协议是怎么设计的？"
- "帧格式是什么样的？"

### 完整故事

#### 背景（Situation）

T95通过串口与多个检测模块通信（TEV板、UHF板等）。最初每个模块的协议是各自定义的，格式不统一。

#### 问题（Task）

1. **丢包问题**：现场电磁环境复杂，串口偶尔会丢字节或收到乱码
2. **协议不统一**：每个模块协议格式不同，新加模块就要写一套解析代码
3. **缺乏重试**：命令发出去不知道有没有收到，出问题只能靠现场反馈

#### 方案（Action）

**第一步：统一帧格式**

```
| 帧头(2B) | 长度(2B) | 命令码(1B) | 序列号(1B) | 数据(NB) | CRC16(2B) |
| 0xAA 0x55|  N+4     |   CMD      |    SEQ     |  DATA    |   CRC     |
```

- **帧头**：固定0xAA 0x55，用于帧同步
- **长度**：从命令码到CRC的总长度
- **序列号**：用于请求-响应匹配和去重
- **CRC16**：校验数据完整性

**第二步：状态机解析**

```cpp
enum class ParseState { WaitHeader1, WaitHeader2, WaitLength, WaitData, WaitCRC };

void onByteReceived(uint8_t byte) {
    switch (parseState_) {
    case ParseState::WaitHeader1:
        if (byte == 0xAA) parseState_ = ParseState::WaitHeader2;
        break;
        
    case ParseState::WaitHeader2:
        if (byte == 0x55) {
            parseState_ = ParseState::WaitLength;
        } else if (byte != 0xAA) {
            parseState_ = ParseState::WaitHeader1;  // 重新找帧头
        }
        break;
        
    case ParseState::WaitLength:
        // 收集长度字节...
        break;
        
    case ParseState::WaitData:
        // 收集数据...
        if (dataComplete) parseState_ = ParseState::WaitCRC;
        break;
        
    case ParseState::WaitCRC:
        // 校验CRC
        if (crcValid) {
            handleFrame(frame);
        } else {
            stats_.crcErrors++;  // 统计CRC错误
        }
        parseState_ = ParseState::WaitHeader1;
        break;
    }
}
```

**第三步：超时重试机制**

```cpp
class ReliableChannel {
    void sendCommand(uint8_t cmd, const QByteArray& data) {
        uint8_t seq = nextSeq_++;
        Frame frame = buildFrame(cmd, seq, data);
        
        // 保存待确认的命令
        pendingCommands_[seq] = {frame, QDateTime::currentMSecsSinceEpoch(), 0};
        
        serialPort_->write(frame.toBytes());
        
        // 启动超时检查
        if (!retryTimer_->isActive()) {
            retryTimer_->start(100);  // 100ms检查一次
        }
    }
    
    void onRetryTimeout() {
        qint64 now = QDateTime::currentMSecsSinceEpoch();
        for (auto& [seq, pending] : pendingCommands_) {
            if (now - pending.sendTime > 500) {  // 500ms超时
                if (pending.retryCount < 3) {
                    // 重发
                    serialPort_->write(pending.frame.toBytes());
                    pending.sendTime = now;
                    pending.retryCount++;
                } else {
                    // 重试3次失败，上报错误
                    emit commandFailed(seq);
                    pendingCommands_.erase(seq);
                }
            }
        }
    }
    
    void onFrameReceived(const Frame& frame) {
        // 收到响应，移除待确认队列
        if (pendingCommands_.contains(frame.seq)) {
            pendingCommands_.erase(frame.seq);
            emit commandSuccess(frame.seq, frame.data);
        }
    }
};
```

#### 结果（Result）

| 指标 | 优化前 | 优化后 |
|------|--------|--------|
| 通信成功率 | ~95% | >99.5% |
| CRC错误检出 | 无 | 100%检出 |
| 平均重试次数 | - | 0.02次/命令 |
| 新模块协议开发时间 | 2周 | 3天 |

### 追问准备

**Q：CRC16用的什么算法？**

> CRC-16/MODBUS，多项式0x8005，初始值0xFFFF。选这个是因为Modbus协议通用，而且有很多现成的实现可以参考验证。

**Q：为什么超时时间设500ms？**

> 根据实测数据定的。正常响应时间在50-100ms，设500ms留足够余量。太短会频繁重试浪费带宽，太长影响用户体验。

**Q：重试会导致重复执行吗？**

> 会。所以序列号很重要。接收方会记住最近处理过的序列号，收到重复的就只回响应不重复执行。

---

## 故事四：多模块数据同步

### 面试官可能的问法

- "不同采样率的数据怎么同步的？"
- "时间戳对齐具体怎么做？"

### 完整故事

#### 背景（Situation）

T95有多个检测模块，采样率不同：
- 红外图像：25Hz
- UHF频谱：1000Hz
- TEV波形：10000Hz

界面上要同时显示这些数据，用户希望看到的是"同一时刻"的检测状态。

#### 问题（Task）

最初各模块独立采集、独立显示，但用户反馈：
1. 看到的红外图像和UHF频谱对不上，不知道是不是同一时刻的
2. 做检测报告时，截图的数据时间点不一致

#### 方案（Action）

**第一步：统一时间戳**

每个数据包都带主机时间戳（采集到的瞬间打上）：

```cpp
struct DataPacket {
    qint64 timestamp;      // 主机时间戳，毫秒
    ModuleType source;     // 来源模块
    QByteArray payload;    // 数据内容
};
```

**第二步：数据对齐显示**

UI显示时，选一个基准时间点，各模块显示最接近该时间点的数据：

```cpp
class SyncDisplayManager {
    // 各模块的数据缓冲，按时间排序
    QMap<qint64, DataPacket> irBuffer_;    // 红外
    QMap<qint64, DataPacket> uhfBuffer_;   // UHF
    QMap<qint64, DataPacket> tevBuffer_;   // TEV
    
    void refreshDisplay(qint64 targetTime) {
        // 找到最接近targetTime的数据
        auto irData = findNearest(irBuffer_, targetTime, 100);   // 100ms容差
        auto uhfData = findNearest(uhfBuffer_, targetTime, 10);  // 10ms容差
        auto tevData = findNearest(tevBuffer_, targetTime, 1);   // 1ms容差
        
        // 显示
        irWidget_->update(irData);
        uhfWidget_->update(uhfData);
        tevWidget_->update(tevData);
    }
    
    DataPacket findNearest(const QMap<qint64, DataPacket>& buffer, 
                           qint64 target, qint64 tolerance) {
        auto it = buffer.lowerBound(target - tolerance);
        if (it == buffer.end()) return {};
        
        // 找前后最近的
        DataPacket best;
        qint64 minDiff = tolerance;
        while (it != buffer.end() && it.key() <= target + tolerance) {
            qint64 diff = qAbs(it.key() - target);
            if (diff < minDiff) {
                minDiff = diff;
                best = it.value();
            }
            ++it;
        }
        return best;
    }
};
```

**第三步：缓冲区管理**

```cpp
void onDataReceived(const DataPacket& packet) {
    auto& buffer = getBuffer(packet.source);
    buffer.insert(packet.timestamp, packet);
    
    // 限制缓冲区大小，删除旧数据
    while (buffer.size() > maxBufferSize_) {
        buffer.erase(buffer.begin());
    }
}
```

#### 结果（Result）

1. 用户反馈数据"看起来同步了"
2. 截图用于报告时，时间戳一致，数据可追溯
3. 后续加了"时间轴回放"功能，因为有时间戳可以轻松定位历史数据

### 追问准备

**Q：时间戳精度够吗？毫秒级的？**

> 对我们的应用场景够了。红外25Hz，一帧40ms；最快的TEV是10kHz，0.1ms一个点，但TEV显示的是波形图而不是单点，所以毫秒级时间戳对齐就够了。

**Q：如果时间戳漂移怎么办？**

> 目前靠主机打时间戳，漂移主要来自采集延迟的抖动，实测在10ms以内。如果要更精确，可以让硬件打时间戳，但需要硬件支持同步时钟，成本更高。

---

## 故事五：快速上手新硬件（红外模块2周接入）

### 面试官可能的问法

- "你怎么快速上手新技术的？"
- "2周接入红外模块，具体怎么做的？"

### 完整故事

#### 背景（Situation）

项目需要集成一个新的红外热成像模块，厂商提供SDK和文档，但团队之前没人做过红外相关开发。

#### 任务（Task）

领导给了2周时间，要求实现：
1. 设备连接与状态管理
2. 伪彩图实时显示
3. 温度标定与测温功能

#### 行动（Action）

**第一周：调研 + 跑通Demo**

- Day 1-2：通读SDK文档和示例代码，理清调用流程
- Day 3-4：搭建最小Demo，能显示红外图像
- Day 5：整理SDK接口，识别哪些是必须的、哪些可以忽略

```cpp
// 最小Demo代码
void minimalDemo() {
    // 1. 初始化SDK
    IR_Init();
    
    // 2. 打开设备
    HANDLE device = IR_OpenDevice(0);
    
    // 3. 注册回调
    IR_SetCallback(device, onFrame, this);
    
    // 4. 开始采集
    IR_StartCapture(device);
}

void onFrame(void* ctx, IRFrame* frame) {
    // 把原始数据转成QImage显示
    QImage img = convertToQImage(frame->data, frame->width, frame->height);
    emit frameReady(img);
}
```

**第二周：集成到项目 + 完善功能**

- Day 6-7：把Demo代码封装成模块，集成状态机
- Day 8-9：实现伪彩色映射、温度显示
- Day 10：联调测试、处理边界情况

```cpp
// 伪彩色映射
QImage applyPseudoColor(const IRFrame& frame, ColorPalette palette) {
    QImage result(frame.width, frame.height, QImage::Format_RGB888);
    
    // 温度范围归一化
    float minTemp = frame.minTemp;
    float maxTemp = frame.maxTemp;
    
    for (int y = 0; y < frame.height; y++) {
        for (int x = 0; x < frame.width; x++) {
            float temp = frame.getTemperature(x, y);
            float normalized = (temp - minTemp) / (maxTemp - minTemp);
            QRgb color = palette.getColor(normalized);
            result.setPixel(x, y, color);
        }
    }
    return result;
}
```

#### 结果（Result）

- 2周内完成全部功能，按时交付
- 封装的红外模块被其他项目复用
- 总结了一份《红外模块接入指南》，后续有新人接手时节省了培训时间

### 追问准备

**Q：遇到文档不全怎么办？**

> 看示例代码比看文档更快。如果示例也没有，就用试错法：调用接口看返回值，打印日志看数据格式。实在不行联系厂商技术支持。

**Q：如果2周做不完怎么办？**

> 第一周末会评估进度。如果Demo都跑不通，说明有根本性问题，要及时反馈。如果Demo通了但功能做不完，就砍需求，先保证核心功能上线。

---

## 面试时的通用技巧

### 1. 先给结论再展开

```
❌ "我们当时遇到一个问题，就是UI很卡，然后我分析了一下..."（面试官不耐烦）
✅ "我用无锁队列把UI延迟从200ms降到50ms。具体是这样的..."（先给结果，再讲过程）
```

### 2. 用数字说话

```
❌ "优化后性能提升了很多"
✅ "优化后延迟从200ms降到50ms，CPU占用从45%降到18%"
```

### 3. 承认边界

```
❌ "这个方案没有任何问题"
✅ "这个方案在我们的场景下是最优的，但如果是多生产者场景，就需要换成MPMC队列"
```

### 4. 不懂就说不懂

```
❌ 编一个听起来合理的答案
✅ "这个我没深入研究过，但我猜测是...，回去后我可以查一下"
```
