# Project Deep-Dive Interview Questions (proj_)

> Extracted from interview prep files. Each question includes id, tags, difficulty, hint, answer, and source.

---

## A. SPSC无锁队列与UI优化

### proj_001
- **question**: 简历上写的无锁队列是怎么回事？你们为什么要用无锁队列？
- **tags**: `[无锁队列, SPSC, 性能优化, 线程同步]`
- **difficulty**: 2
- **hint**: 从场景（采集1000Hz vs UI 30Hz）入手，说明mutex的问题，再引出SPSC方案。
- **source**: 简历技术点故事.md

**answer**:

**【S - 背景】**
T95是一个电力检测手持终端，要实时显示多种传感器数据——红外图像、UHF频谱、TEV波形。数据采集线程在后台高速运行，UI线程负责刷新显示。

**【T - 问题】**
上线初期用户反馈界面卡顿，特别是切换检测模式时，UI会卡住1-2秒。我用日志埋点分析后发现：
1. **数据线程和UI线程用`QMutex`同步**，锁竞争严重
2. **UI线程频繁刷新**，每来一帧数据就刷一次，但数据采集速率是1000Hz，屏幕才60Hz
3. **数据拷贝开销大**，每次刷新都要深拷贝整个数据包

**【A - 方案】**
我主导了数据管线重构，分三步：

**第一步：引入SPSC无锁队列** — 单生产者单消费者场景，用无锁队列替代互斥锁。核心是两个原子变量（head/tail）+ 环形缓冲区，生产者只写head，消费者只写tail，用memory_order保证可见性。

**第二步：控频刷新** — UI不再被动响应数据到来，而是主动按固定频率（30Hz）拉取最新数据，中间帧丢弃。

**第三步：减少数据拷贝** — 用`std::shared_ptr`共享数据包，避免深拷贝。

**【R - 结果】**

| 指标 | 优化前 | 优化后 |
|------|--------|--------|
| UI刷新延迟 | 200ms | 50ms |
| CPU占用（UI线程） | 45% | 18% |
| 切换模式卡顿 | 1-2秒 | 无感知 |

---

### proj_002
- **question**: UI延迟从200ms降到50ms，具体怎么做到的？
- **tags**: `[性能优化, UI刷新, 控频策略, 数据管线]`
- **difficulty**: 2
- **hint**: 强调三步走：无锁队列消除锁竞争 → 控频刷新降低CPU → shared_ptr减少拷贝。
- **source**: 简历技术点故事.md

**answer**:

三个优化叠加的效果：

1. **无锁队列替代mutex** — 原来每次push/pop都要加锁解锁，1000Hz就是每秒2000次锁操作，最坏延迟500μs。改用SPSC无锁队列后平均延迟从5μs降到0.1μs，吞吐量从100万/秒提升到1000万/秒。

2. **控频刷新策略** — UI按30Hz定时器拉取，每次只取队列中最新的一帧（while循环pop到空，保留最后一帧），不再每帧都刷新。

3. **shared_ptr避免拷贝** — 数据包用`std::shared_ptr<DataPacket>`包装，队列传递的是指针而非完整数据，600KB/帧的红外数据不再深拷贝。

综合效果：延迟200ms→50ms，CPU占用45%→18%，切换模式从1-2秒卡顿变为无感知。

---

### proj_003
- **question**: 为什么不用Qt的信号槽？
- **tags**: `[Qt, 信号槽, 性能对比, 架构选型]`
- **difficulty**: 2
- **hint**: 从信号槽的开销（类型擦除、动态分配、通用设计）和场景匹配（SPSC场景更简单高效）两方面回答。
- **source**: 简历技术点故事.md / 深度问题_无锁队列.md

**answer**:

信号槽底层也是事件队列，但：
1. 有类型擦除和QVariant转换开销
2. 跨线程时会动态分配内存
3. 通用设计，对高频场景过重

自己实现的好处：
1. 针对场景优化，零拷贝（shared_ptr）
2. 控制队列满时的行为（丢弃旧数据而非阻塞）
3. 方便加监控统计

信号槽是多生产者安全的，我们不需要这个额外开销。

---

### proj_004
- **question**: 无锁队列会丢数据吗？
- **tags**: `[无锁队列, 数据丢失, 容错设计]`
- **difficulty**: 2
- **hint**: 承认会丢，但解释为什么可以丢——采集1000Hz、显示30Hz，关键是"最新数据能显示"。
- **source**: 简历技术点故事.md / 深度问题_无锁队列.md

**answer**:

会，队列满了push会失败。但我们的场景允许丢帧：
- 采集1000Hz，显示30Hz，大部分帧本来就不显示
- 关键是保证"最新数据能显示"，而非"每帧都显示"
- 丢弃的是中间帧，不影响实时性

如果不允许丢失：
- 可以用阻塞队列
- 或者用可变大小的队列（但需要锁保护分配）

我们项目是每个检测模块一个队列，正好是SPSC。

---

### proj_005
- **question**: memory_order为什么这么写？各级别什么意思？
- **tags**: `[内存序, 原子操作, C++并发, memory_order]`
- **difficulty**: 3
- **hint**: 画出生产者和消费者的读写关系图：release保证buffer写入在head更新之前，acquire保证buffer读取在看到head更新之后。
- **source**: 简历技术点故事.md / 深度问题_无锁队列.md

**answer**:

六种memory_order从弱到强：
- `relaxed`：只保证原子性，允许任意重排
- `consume`：依赖当前值的操作不能重排到前面（基本不用）
- `acquire`：之后的读写不能重排到前面（读屏障）
- `release`：之前的读写不能重排到后面（写屏障）
- `acq_rel`：acquire + release
- `seq_cst`：最严格，全局顺序一致（默认）

**SPSC队列中的选择**：
```
生产者：                          消费者：
  buffer_[head] = item;  ─────┐
         ↓                    │
  head_.store(release)  ──────┼──> head_.load(acquire)
                              │          ↓
                              └──> item = buffer_[tail];
```
- `relaxed`：读自己的变量，不需要同步
- `acquire`：读对方的变量，要看到对方之前的写
- `release`：写完后让对方能看到

这是SPSC的标准写法，比`seq_cst`性能好，但要确保只有一个生产者一个消费者。

**常见错误**：
- 全用relaxed → 消费者可能看不到buffer的写入
- 全用seq_cst → 能用，但性能差
- load用release或store用acquire → 搞反了

---

### proj_006
- **question**: 为什么队列大小是64？容量怎么选？
- **tags**: `[队列容量, 缓冲区设计, 性能调优]`
- **difficulty**: 2
- **hint**: 根据生产者速率和消费者最大延迟计算，例如1000Hz×0.1s=100→取128（2的幂）。
- **source**: 简历技术点故事.md / 深度问题_无锁队列.md

**answer**:

根据实际测试调的。太小容易溢出，太大浪费内存。64帧≈2秒的数据缓冲，够UI线程处理了。

容量选择原则：
- 容量必须是2的幂，用位运算代替取模：`(head + 1) & (Capacity - 1)` 比 `% Capacity` 快
- 根据生产者速率和消费者最大延迟计算，例如：1000Hz生产，消费者最多卡100ms → 容量 = 1000 × 0.1 = 100，取128（2的幂）
- 太小：容易满，数据丢失
- 太大：浪费内存

---

### proj_007
- **question**: 多生产者怎么办？SPSC不支持多生产者的场景如何处理？
- **tags**: `[MPSC, MPMC, 并发队列, 架构选型]`
- **difficulty**: 3
- **hint**: 三种方案：每个生产者一个队列（我们的方案）、MPSC队列、mutex保护的队列。
- **source**: 深度问题_无锁队列.md

**answer**:

SPSC不支持多生产者，可以：

- **方案1**：每个生产者一个队列，消费者轮询 — 我们项目的做法，每个检测模块一个队列
- **方案2**：用MPSC（多生产者单消费者）队列
- **方案3**：用mutex保护的队列（简单，性能够用就行）

其他无锁数据结构对比：

| 数据结构 | 复杂度 | 应用场景 |
|----------|--------|----------|
| SPSC Queue | 简单 | 单生产者单消费者 |
| MPSC Queue | 中等 | 多生产者单消费者（日志系统） |
| MPMC Queue | 复杂 | 线程池任务队列 |
| Lock-free Stack | 中等 | 内存池 |

---

### proj_008
- **question**: 怎么测试无锁队列的正确性？
- **tags**: `[测试, 并发测试, ThreadSanitizer, 压力测试]`
- **difficulty**: 2
- **hint**: 三层测试：单元测试验证基本逻辑 → 并发测试用TSan检测竞争 → 压力测试跑24小时。
- **source**: 深度问题_无锁队列.md

**answer**:

1. **单元测试**
   - 空队列pop返回false
   - 满队列push返回false
   - push后pop能取到正确数据

2. **并发测试**
   - 两个线程分别push和pop
   - 跑百万次，检查数据完整性
   - 用ThreadSanitizer检测数据竞争

3. **压力测试**
   - 跑24小时，检查内存泄漏和崩溃

---

### proj_009
- **question**: 有没有现成的无锁队列库？为什么自己写？
- **tags**: `[第三方库, Boost, folly, 依赖管理]`
- **difficulty**: 1
- **hint**: 有现成库（Boost.Lockfree、folly），但自己写的原因：学习目的、需求简单、减少依赖。
- **source**: 深度问题_无锁队列.md

**answer**:

有，比如：
- Boost.Lockfree
- folly::ProducerConsumerQueue
- moodycamel::ConcurrentQueue

为什么自己写：
1. 学习目的，理解原理
2. 我们的需求简单，200行代码搞定
3. 减少外部依赖

---

## B. 状态机管理设备连接

### proj_010
- **question**: 状态机是怎么用的？为什么要用状态机？
- **tags**: `[状态机, 设备管理, 代码重构, 设计模式]`
- **difficulty**: 2
- **hint**: 从问题出发——状态标志散落各处导致8种组合容易漏，用状态机集中管理转换逻辑。
- **source**: 简历技术点故事.md

**answer**:

**【S - 背景】**
T95要对接一个红外热成像模块，通过USB连接。连接不太稳定，USB偶尔会断开重连，初始化需要几秒钟。

**【T - 问题】**
最初代码用多个bool标志（`isConnected`、`isInitializing`、`isError`）管理状态，组合起来有8种情况容易漏。断开重连时偶尔崩溃，新同事经常问"这个状态下能不能调这个函数"。

**【A - 方案】**
定义5个状态（Disconnected/Connecting/Initializing/Ready/Error）和7种事件，用switch-case集中管理状态转换。画出状态图文档：
```
[Disconnected] --UsbAttached--> [Connecting]
[Connecting] --InitSuccess--> [Initializing]
[Connecting] --Timeout/UsbDetached--> [Disconnected]
[Initializing] --InitSuccess--> [Ready]
[Initializing] --InitFailed--> [Error]
[Ready] --UsbDetached--> [Disconnected]
[Error] --Reset--> [Disconnected]
```

**【R - 结果】**
1. 重构后3个月内没有再出现连接相关的崩溃
2. 新同事看状态图就能理解逻辑
3. 后来加"固件升级"状态，只需要加一个状态和几条转换

---

### proj_011
- **question**: 为什么不用Qt的QStateMachine？
- **tags**: `[Qt, QStateMachine, 轻量设计]`
- **difficulty**: 2
- **hint**: QStateMachine适合复杂UI状态管理，我们状态少（5个），自己写更轻量可控，调试时直接打印枚举值。
- **source**: 简历技术点故事.md

**answer**:

考虑过，但QStateMachine比较重，适合复杂的UI状态管理。我们这个场景状态不多（5个），自己写更轻量、更可控。而且调试时直接打印枚举值就能看状态，QStateMachine还得去查state name。

---

### proj_012
- **question**: 状态转换是线程安全的吗？
- **tags**: `[线程安全, Qt信号槽, 事件驱动]`
- **difficulty**: 2
- **hint**: 所有事件都通过Qt信号槽投递到主线程处理，状态机本身单线程，不需要加锁。
- **source**: 简历技术点故事.md

**answer**:

所有事件都通过Qt的信号槽投递到主线程处理，所以状态机本身是单线程的，不需要加锁。USB事件来自系统回调，我用`QMetaObject::invokeMethod`转到主线程。

---

### proj_013
- **question**: 状态机怎么处理超时？
- **tags**: `[超时处理, QTimer, 状态管理]`
- **difficulty**: 2
- **hint**: 每次进入需要等待的状态就启动QTimer，超时触发Timeout事件，进入下一状态时取消定时器。
- **source**: 简历技术点故事.md

**answer**:

每次进入需要等待的状态（Connecting、Initializing）就启动一个`QTimer`，超时触发Timeout事件。进入下一个状态时取消定时器。

---

## C. 协议解析与通信可靠性

### proj_014
- **question**: CRC校验、重试机制具体怎么做的？通信协议是怎么设计的？
- **tags**: `[通信协议, CRC16, 重试机制, 帧格式, 状态机解析]`
- **difficulty**: 2
- **hint**: 三步走：统一帧格式（帧头+长度+命令码+序列号+数据+CRC） → 状态机逐字节解析 → 超时重试机制（3次/500ms）。
- **source**: 简历技术点故事.md

**answer**:

**【S】** T95通过串口与多个检测模块通信。最初每个模块协议格式不统一，丢包问题严重，缺乏重试机制。

**【A】** 三步优化：

**第一步：统一帧格式**
```
| 帧头(2B) | 长度(2B) | 命令码(1B) | 序列号(1B) | 数据(NB) | CRC16(2B) |
| 0xAA 0x55|  N+4     |   CMD      |    SEQ     |  DATA    |   CRC     |
```
- 帧头0xAA 0x55用于帧同步
- 序列号用于请求-响应匹配和去重

**第二步：状态机解析** — WaitHeader1→WaitHeader2→WaitLength→WaitData→WaitCRC，逐字节处理，CRC错误计入统计。

**第三步：超时重试机制** — 发送命令时保存到待确认队列，100ms轮询检查，500ms超时重试，最多3次，3次失败上报错误。接收方用序列号去重。

**【R】**

| 指标 | 优化前 | 优化后 |
|------|--------|--------|
| 通信成功率 | ~95% | >99.5% |
| CRC错误检出 | 无 | 100%检出 |
| 平均重试次数 | - | 0.02次/命令 |
| 新模块协议开发时间 | 2周 | 3天 |

---

### proj_015
- **question**: CRC16用的什么算法？
- **tags**: `[CRC16, Modbus, 校验算法]`
- **difficulty**: 2
- **hint**: CRC-16/MODBUS，多项式0x8005，初始值0xFFFF，选择原因是Modbus通用且有大量参考实现。
- **source**: 简历技术点故事.md

**answer**:

CRC-16/MODBUS，多项式0x8005，初始值0xFFFF。选这个是因为Modbus协议通用，而且有很多现成的实现可以参考验证。

---

### proj_016
- **question**: 为什么超时时间设500ms？
- **tags**: `[超时设计, 参数调优, 通信延迟]`
- **difficulty**: 2
- **hint**: 根据实测数据定的——正常响应50-100ms，留足够余量；太短频繁重试浪费带宽，太长影响体验。
- **source**: 简历技术点故事.md

**answer**:

根据实测数据定的。正常响应时间在50-100ms，设500ms留足够余量。太短会频繁重试浪费带宽，太长影响用户体验。

---

### proj_017
- **question**: 重试会导致重复执行吗？
- **tags**: `[幂等性, 序列号, 去重机制]`
- **difficulty**: 2
- **hint**: 会，所以序列号很重要——接收方记住最近处理过的序列号，收到重复的只回响应不重复执行。
- **source**: 简历技术点故事.md

**answer**:

会。所以序列号很重要。接收方会记住最近处理过的序列号，收到重复的就只回响应不重复执行。这是一种简单的幂等性保证。

---

## D. 多模块数据同步

### proj_018
- **question**: 不同采样率的数据怎么同步的？时间戳对齐具体怎么做？
- **tags**: `[数据同步, 时间戳对齐, 多采样率, 缓冲区管理]`
- **difficulty**: 2
- **hint**: 三步：统一时间戳（主机时间戳） → 数据对齐显示（按基准时间点找最近帧，各模块不同容差） → 缓冲区大小限制。
- **source**: 简历技术点故事.md

**answer**:

**【S】** T95有多个检测模块，采样率不同：红外25Hz、UHF 1000Hz、TEV 10000Hz。用户希望看到"同一时刻"的检测状态。

**【A】**

**第一步：统一时间戳** — 每个数据包都带主机时间戳（采集到的瞬间打上）。

**第二步：数据对齐显示** — UI显示时选一个基准时间点，各模块用`findNearest`找最接近该时间点的数据，各模块容差不同（红外100ms、UHF 10ms、TEV 1ms）。

**第三步：缓冲区管理** — 用QMap按时间排序存储，限制缓冲区大小，超出删除旧数据。

**【R】**
1. 用户反馈数据"看起来同步了"
2. 截图用于报告时，时间戳一致，数据可追溯
3. 后续加了"时间轴回放"功能，因为有时间戳可以轻松定位历史数据

---

### proj_019
- **question**: 时间戳精度够吗？毫秒级的？
- **tags**: `[时间戳精度, 采样率, 应用场景]`
- **difficulty**: 2
- **hint**: 对应用场景够了——红外25Hz一帧40ms，TEV虽然10kHz但显示的是波形图而非单点。
- **source**: 简历技术点故事.md

**answer**:

对我们的应用场景够了。红外25Hz，一帧40ms；最快的TEV是10kHz，0.1ms一个点，但TEV显示的是波形图而不是单点，所以毫秒级时间戳对齐就够了。

---

### proj_020
- **question**: 如果时间戳漂移怎么办？
- **tags**: `[时间同步, 时间漂移, 硬件时钟]`
- **difficulty**: 3
- **hint**: 目前靠主机打时间戳，漂移主要来自采集延迟的抖动（实测10ms以内）；更精确需要硬件同步时钟。
- **source**: 简历技术点故事.md

**answer**:

目前靠主机打时间戳，漂移主要来自采集延迟的抖动，实测在10ms以内。如果要更精确，可以让硬件打时间戳，但需要硬件支持同步时钟，成本更高。

---

## E. 快速上手新硬件

### proj_021
- **question**: 你怎么快速上手新技术的？2周接入红外模块，具体怎么做的？
- **tags**: `[快速学习, 硬件集成, SDK对接, 项目管理]`
- **difficulty**: 2
- **hint**: 两周节奏：第一周通读SDK文档+跑通最小Demo+识别核心API；第二周封装模块+集成状态机+联调测试。
- **source**: 简历技术点故事.md

**answer**:

**【S】** 项目需要集成新的红外热成像模块，厂商提供SDK和文档，团队之前没人做过红外开发。

**【T】** 2周内完成设备连接与状态管理、伪彩图实时显示、温度标定与测温功能。

**【A】**
- **第一周：调研+跑通Demo**
  - Day 1-2：通读SDK文档和示例代码，理清调用流程
  - Day 3-4：搭建最小Demo（IR_Init→IR_OpenDevice→IR_SetCallback→IR_StartCapture），能显示红外图像
  - Day 5：整理SDK接口，识别核心API vs 可忽略API

- **第二周：集成+完善**
  - Day 6-7：把Demo代码封装成模块，集成状态机
  - Day 8-9：实现伪彩色映射（温度归一化→调色板查表）、温度显示
  - Day 10：联调测试、处理边界情况

**【R】**
- 2周内完成全部功能，按时交付
- 封装的红外模块被其他项目复用
- 总结了一份《红外模块接入指南》，节省后续培训时间

---

### proj_022
- **question**: 遇到文档不全怎么办？
- **tags**: `[SDK对接, 问题解决, 调试方法]`
- **difficulty**: 1
- **hint**: 看示例代码比看文档更快；试错法：调接口看返回值、打日志看数据格式；实在不行联系厂商技术支持。
- **source**: 简历技术点故事.md

**answer**:

看示例代码比看文档更快。如果示例也没有，就用试错法：调用接口看返回值，打印日志看数据格式。实在不行联系厂商技术支持。

---

### proj_023
- **question**: 如果2周做不完怎么办？
- **tags**: `[项目管理, 风险评估, 需求优先级]`
- **difficulty**: 1
- **hint**: 第一周末评估进度——Demo跑不通说明有根本问题要及时反馈，Demo通了但功能做不完就砍需求先保核心。
- **source**: 简历技术点故事.md

**answer**:

第一周末会评估进度。如果Demo都跑不通，说明有根本性问题，要及时反馈。如果Demo通了但功能做不完，就砍需求，先保证核心功能上线。

---

## F. 模块集成优化（3个月→6周）

### proj_024
- **question**: 模块集成周期从3个月缩短到6周，怎么做到的？
- **tags**: `[模块化, 接口设计, 框架设计, 代码复用]`
- **difficulty**: 2
- **hint**: 三件事：统一接口规范（IDetectionModule） → 基础设施复用（状态机、协议解析、数据管线） → 工厂模式自动注册。
- **source**: 深度问题_模块集成优化.md

**answer**:

**原来为什么慢（3个月/14周）？**
- 重复造轮子：每个模块都写一套连接管理、数据解析、错误处理
- 代码风格不统一，后续维护困难
- 没有统一接口，每次集成都要改主程序
- 没有统一测试框架，bug到现场才发现

**解决方案：模块化框架**

1. **统一接口** — 定义`IDetectionModule`基类，包含生命周期（initialize/shutdown）、连接管理（connect/disconnect）、数据采集（startAcquisition/stopAcquisition）、信息查询（getType/getName/getVersion）和信号通知（dataReady/connectionStateChanged/errorOccurred）

2. **模块注册机制** — 工厂模式+宏简化注册：`REGISTER_MODULE(ModuleType::TEV, TevModule)`

3. **基础设施复用** — ConnectionStateMachine（通用连接状态机）、FrameParser（通用帧解析器）、DataPipeline（数据处理管线），新模块直接复用

**节省对比**:

| 项目 | 原来 | 现在 | 节省 |
|------|------|------|------|
| 连接管理 | 1周 | 复用 | 1周 |
| 协议解析 | 2周 | 配置化 | 1.5周 |
| 数据处理 | 2周 | 管线配置 | 1周 |
| UI显示 | 2周 | 控件复用 | 1周 |
| 集成 | 1周 | 自动注册 | 1周 |
| 测试 | 2周 | 统一框架 | 1周 |
| **总计** | **14周** | **6周** | **8周** |

---

### proj_025
- **question**: 接口设计时怎么考虑的？
- **tags**: `[接口设计, API设计, 最小化原则]`
- **difficulty**: 3
- **hint**: 三点：最小化接口（只定义必须的方法）→ 三层生命周期分离（资源/连接/采集）→ 异步信号通知解耦。
- **source**: 深度问题_模块集成优化.md

**answer**:

主要考虑三点：

1. **最小化接口** — 只定义必须的方法，不过度设计。具体模块可以有自己的扩展接口。

2. **生命周期管理** — initialize/shutdown（资源申请释放）、connect/disconnect（设备连接）、start/stop（数据采集），三层分离，状态清晰。

3. **信号通知** — 数据就绪、状态变化、错误发生，用Qt信号槽异步解耦。

---

### proj_026
- **question**: 遇到不符合接口的模块怎么办？
- **tags**: `[适配器模式, 设计模式, 兼容性]`
- **difficulty**: 2
- **hint**: 适配器模式——封装原有SDK为统一接口的子类，设计时预留了这种灵活性。
- **source**: 深度问题_模块集成优化.md

**answer**:

用适配器模式。比如某个SDK的回调机制和我们不一样：
```cpp
class LegacyModuleAdapter : public IDetectionModule {
    LegacySDK sdk_;  // 封装原有SDK
    bool connect() override {
        return sdk_.Open() && sdk_.Configure(config_);
    }
};
```
设计时预留了这种灵活性。

---

### proj_027
- **question**: 怎么保证模块间不互相影响？
- **tags**: `[模块隔离, 线程隔离, 错误隔离]`
- **difficulty**: 2
- **hint**: 四层隔离：独立线程+独立数据队列 → 只通过接口通信 → 无全局状态 → 一个模块出错不影响其他。
- **source**: 深度问题_模块集成优化.md

**answer**:

1. **隔离**：每个模块独立的线程、独立的数据队列
2. **接口**：只通过IDetectionModule接口通信
3. **无全局状态**：不使用全局变量
4. **错误隔离**：一个模块出错不影响其他模块

实测：关闭TEV模块时，红外模块照常工作。

---

### proj_028
- **question**: 6周是怎么估算的？
- **tags**: `[工时估算, 项目管理, 数据驱动]`
- **difficulty**: 1
- **hint**: 根据实际数据——红外模块首个用新框架接入5周，AE模块4周，后续稳定在4-6周，6周是保守估计。
- **source**: 深度问题_模块集成优化.md

**answer**:

根据实际数据：
- 红外模块：首个用新框架接入，5周
- AE模块：第二个接入，4周
- 后续模块：稳定在4-6周

6周是保守估计，包含一些buffer。比不用框架的3个月（14周）节省了8周。

---

## G. 15MB/s数据处理

### proj_029
- **question**: 系统可流畅处理15MB/s实时数据流，具体怎么做到的？
- **tags**: `[高吞吐, 流水线, 零拷贝, 控频刷新, 实时处理]`
- **difficulty**: 3
- **hint**: 四大优化：流水线并行（采集→解析→处理→显示各环节异步）→ 零拷贝（内存池/shared_ptr）→ 控频显示30Hz → SIMD加速。
- **source**: 深度问题_15MB数据处理.md

**answer**:

**数据量分析**：红外640×480×2B×25Hz = 15MB/s，是大头。

**优化前问题**：
- 数据拷贝600KB/帧，每秒25帧
- 同步处理阻塞采集
- UI刷新时采集停顿
- 处理一帧15ms，接近40ms/帧的预算

**优化方案**：

1. **流水线架构** — 采集→解析→处理→显示四个环节各自独立线程，队列解耦，前一环节不等后一环节

2. **零拷贝设计** — 使用内存池预分配帧缓冲区，或SDK buffer直接使用不拷贝

3. **控频显示** — 30Hz定时器刷新，只在有新帧时才刷新UI

4. **SIMD加速** — 颜色映射用SIMD 8像素并行处理，640×480帧耗时从3000μs降到400μs

**测试结果**：

| 配置 | FPS | 吞吐量 | CPU占用 |
|------|-----|--------|---------|
| 优化前 | 18 | 10.5MB/s | 85% |
| +零拷贝 | 25 | 15MB/s | 70% |
| +并行处理 | 30 | 18MB/s | 80%（多核） |
| +控频显示 | 30 | 18MB/s | 50% |
| +SIMD | 40 | 24MB/s | 40% |

最终：稳定处理25Hz×600KB=15MB/s，CPU占用50%，无丢帧无卡顿。

---

### proj_030
- **question**: 15MB/s是怎么测量的？
- **tags**: `[性能测量, 基准测试, 吞吐量]`
- **difficulty**: 2
- **hint**: 红外帧640×480×2B=614,400B × 25fps = 15,360,000 B/s ≈ 15MB/s，用性能计数器验证稳定25帧。
- **source**: 深度问题_15MB数据处理.md

**answer**:

测量方法：
1. 记录一段时间内处理的总字节数
2. 除以时间得到平均吞吐量

具体：
- 红外帧：640×480×2B = 614,400B
- 帧率：25fps
- 吞吐量：614,400 × 25 = 15,360,000 B/s ≈ 15MB/s

验证：用性能计数器统计每秒处理的帧数，稳定在25帧。

---

### proj_031
- **question**: 瓶颈在哪？怎么找到的？
- **tags**: `[性能分析, 瓶颈定位, profiler]`
- **difficulty**: 2
- **hint**: 排除法：先测整体延迟 → 分段加时间戳定位到处理（50ms）和UI刷新（100ms） → 针对性优化。
- **source**: 深度问题_15MB数据处理.md

**answer**:

用排除法：

1. 先测整体延迟：采集到显示200ms
2. 分段加时间戳：
   - 采集：5ms
   - 解析：2ms
   - 处理：50ms ← 主要瓶颈
   - UI刷新：100ms ← 另一个瓶颈
3. 针对性优化

最后发现：
- 处理瓶颈：颜色映射算法慢 → SIMD优化
- UI瓶颈：刷新太频繁 → 控频刷新

---

### proj_032
- **question**: 内存占用怎么样？
- **tags**: `[内存管理, 内存池, 嵌入式约束]`
- **difficulty**: 2
- **hint**: 流水线3个队列×8帧×600KB=14.4MB最坏情况，实际用内存池预分配20帧buffer=12MB，运行时不再分配。
- **source**: 深度问题_15MB数据处理.md

**answer**:

分析：
- 每帧600KB
- 流水线有3个队列，每个8帧深度
- 最坏情况：600KB × 8 × 3 = 14.4MB

实际：
- 用内存池，预分配20帧的buffer
- 总内存：600KB × 20 = 12MB
- 运行时不再分配，无内存碎片

对于嵌入式设备（通常1-2GB内存），12MB完全可接受。

---

### proj_033
- **question**: 如果数据量再大10倍怎么办？
- **tags**: `[架构扩展, FPGA, GPU加速, 分布式]`
- **difficulty**: 3
- **hint**: 三个方向：硬件方案（FPGA/GPU/DMA） → 软件方案（降采样/压缩/分布式） → 架构调整（采集处理分设备）。
- **source**: 深度问题_15MB数据处理.md

**answer**:

150MB/s就需要更激进的优化：

1. **硬件方案** — 使用FPGA做前端处理、GPU加速、DMA直接传输
2. **软件方案** — 降采样减少数据量、传输压缩数据CPU解压、分布式多机处理
3. **架构调整** — 采集和处理分离到不同设备、用高速接口（PCIe、万兆网）

我们当前设备是ARM平台，15MB/s是合理的上限。

---

### proj_034
- **question**: 延迟和吞吐量怎么平衡？
- **tags**: `[延迟vs吞吐, 队列深度, trade-off]`
- **difficulty**: 3
- **hint**: trade-off：队列深度大→吞吐↑延迟↑，队列深度小→延迟↓可能丢帧。根据场景差异化设计。
- **source**: 深度问题_15MB数据处理.md

**answer**:

这是个trade-off：
- 增加队列深度 → 吞吐量↑，延迟↑
- 减少队列深度 → 延迟↓，可能丢帧

我们的选择：
- 采集队列：8帧（优先保证不丢帧）
- 显示队列：2帧（优先保证实时性）

最终效果：
- 端到端延迟：80-100ms
- 丢帧率：<0.1%

对于电力检测场景，100ms延迟可接受，丢帧不可接受。

---

## H. 通信优化100ms→60ms

### proj_035
- **question**: 响应时间从100ms优化到60ms，具体优化了哪里？
- **tags**: `[响应优化, IPC, 二进制协议, 异步化, 共享内存]`
- **difficulty**: 2
- **hint**: 四大优化：JSON→二进制协议（15ms→0.1ms） → TCP→共享内存（30ms→0.5ms） → 同步→异步回调 → 驱动保持连接。
- **source**: 深度问题_通信优化100到60ms.md

**answer**:

**【场景】** 柜外交互终端对接多种外设（密码键盘、IC卡读卡器等），通过中转服务通信。用户反馈刷IC卡后屏幕显示慢，测量100ms，目标60ms。

**【瓶颈分析】**

| 阶段 | 耗时 | 说明 |
|------|------|------|
| 驱动回调 | 5ms | 无法优化 |
| 数据序列化 | 15ms | JSON序列化 |
| 进程间通信 | 30ms | Socket通信 |
| 中转服务处理 | 20ms | 协议转换 |
| 响应等待 | 20ms | 同步等待 |
| UI更新 | 10ms | 界面刷新 |

**【优化措施】**

1. **协议优化**：JSON→二进制协议（`#pragma pack`紧凑结构体直接memcpy），序列化从15ms降到0.1ms
2. **通信方式优化**：TCP→共享内存（同机通信），从30ms降到0.5ms
3. **异步化改造**：同步阻塞→异步回调+乐观UI更新，消除20ms等待
4. **驱动调用优化**：每次初始化→驱动保持连接+懒初始化

**【结果】** 实际总延迟：5+0.1+0.5+15+10 = 30.6ms。简历写60ms留了余量，实际更好。

---

### proj_036
- **question**: 为什么选共享内存而不是其他IPC方式？
- **tags**: `[IPC, 共享内存, 性能对比, 架构选型]`
- **difficulty**: 2
- **hint**: 对比各种IPC延迟：TCP高/命名管道中/共享内存低，我们是同机器+延迟敏感，复杂度通过封装解决。
- **source**: 深度问题_通信优化100到60ms.md

**answer**:

| 方式 | 延迟 | 复杂度 | 适用场景 |
|------|------|--------|----------|
| TCP | 高 | 低 | 跨机器 |
| UDP | 中 | 低 | 跨机器、允许丢包 |
| 命名管道 | 中 | 中 | 同机器 |
| 共享内存 | 低 | 高 | 同机器、高性能 |
| 消息队列 | 中 | 中 | 异步场景 |

我们是同机器通信、对延迟敏感，所以选共享内存。复杂度高的问题通过封装解决。

---

### proj_037
- **question**: 共享内存有什么坑？
- **tags**: `[共享内存, 同步问题, 调试, 陷阱]`
- **difficulty**: 3
- **hint**: 四个坑：同步问题（加锁+进程崩溃锁未释放）→ 内存管理（不能放指针，只能POD）→ 版本兼容 → 调试困难。
- **source**: 深度问题_通信优化100到60ms.md

**answer**:

1. **同步问题** — 多进程访问需要加锁，要处理进程崩溃时锁未释放的情况
2. **内存管理** — 共享内存里不能放指针（地址在不同进程不同），只能放plain old data
3. **版本兼容** — 两边的数据结构定义要一致，升级时要考虑兼容性
4. **调试困难** — 数据是二进制的，不好看，需要专门的调试工具

通过定义清晰的协议、添加版本号、写调试工具来解决。

---

### proj_038
- **question**: 60ms的指标是怎么验证的？
- **tags**: `[性能验证, 延迟测量, P95/P99]`
- **difficulty**: 2
- **hint**: 三种验证：代码埋点（P50/P95/P99）→ 外部高速摄像机 → 用户反馈。
- **source**: 深度问题_通信优化100到60ms.md

**answer**:

验证方法：
1. **代码埋点** — 关键节点打时间戳，统计P50、P95、P99延迟
2. **外部测量** — 用高速摄像机拍摄，从刷卡动作到屏幕变化
3. **用户反馈** — 优化前10%的用户反馈"慢"，优化后几乎无反馈

实测P95延迟：优化前120ms → 优化后45ms

---

### proj_039
- **question**: 还能继续优化吗？
- **tags**: `[优化极限, 收益递减, trade-off]`
- **difficulty**: 2
- **hint**: 理论上可以但收益递减——驱动层5ms需要换硬件，中转服务15ms可能再省5ms，但30ms已足够好。
- **source**: 深度问题_通信优化100到60ms.md

**answer**:

理论上可以，但收益递减：
1. **驱动层（5ms）** — 换更快硬件、改驱动代码（需要厂商配合）
2. **中转服务（15ms）** — 进一步优化代码，可能再省5ms
3. **UI层（10ms）** — 用更轻量的控件、预渲染

但现在30ms已经足够好了，用户感知不出差异。投入产出比不高，不值得继续优化。

---

### proj_040
- **question**: 这个优化对系统其他指标有影响吗？
- **tags**: `[trade-off, 副作用, 系统指标]`
- **difficulty**: 2
- **hint**: 三个trade-off：CPU占用略增（+2-3%）、内存增加（+64KB）、代码复杂度增加（通过封装控制），总体值得。
- **source**: 深度问题_通信优化100到60ms.md

**answer**:

有一些trade-off：
1. **CPU占用略增** — 共享内存需要轮询或事件等待，实测增加2-3%，可接受
2. **内存占用增加** — 共享内存需要预分配，增加64KB，可忽略
3. **代码复杂度增加** — 需要处理同步、超时等，通过良好封装控制复杂度

总体是值得的，核心指标（响应时间）提升明显。

---

## I. 交叉编译

### proj_041
- **question**: 交叉编译环境怎么搭建的？遇到什么问题？
- **tags**: `[交叉编译, RK3399, aarch64, sysroot, Qt]`
- **difficulty**: 2
- **hint**: 五步走：安装工具链 → 获取sysroot → 配置Qt mkspec → 编译Qt源码 → 配置Qt Creator。
- **source**: 深度问题_交叉编译.md

**answer**:

**环境**：Ubuntu 20.04 + RK3399 (aarch64-linux-gnu-g++)

**搭建步骤**：
1. 安装交叉编译工具链：`sudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu`
2. 准备sysroot：从目标设备拷贝/usr/include和/usr/lib，或使用SDK提供的
3. 配置Qt：创建mkspec配置文件（qmake.conf指定交叉编译器路径）
4. 编译Qt源码：`./configure -xplatform linux-aarch64-gnu-g++ -sysroot ...` + `make -j8`
5. 配置Qt Creator：添加Qt版本、编译器、Kit、Sysroot

**命名规则**：`aarch64-linux-gnu-g++` = 64位ARM架构-Linux系统-GNU C库-编译器

---

### proj_042
- **question**: 交叉编译和本地编译有什么区别？
- **tags**: `[交叉编译, 本地编译, 工具链]`
- **difficulty**: 1
- **hint**: 四个区别：编译器不同、查找路径不同（sysroot）、运行方式不同（传到目标设备）、调试方式不同（gdbserver远程）。
- **source**: 深度问题_交叉编译.md

**answer**:

- **编译器不同**：本地用gcc，交叉用aarch64-linux-gnu-gcc
- **查找路径不同**：本地在/usr/include、/usr/lib，交叉在sysroot下
- **运行方式不同**：本地直接运行，交叉需要传到目标设备
- **调试方式不同**：本地直接gdb，交叉需要gdbserver远程调试

---

### proj_043
- **question**: 为什么需要sysroot？
- **tags**: `[sysroot, 头文件, 库文件, 交叉编译]`
- **difficulty**: 2
- **hint**: sysroot包含目标系统的头文件和库——告诉编译器"去这个目录找，不要用系统的"，否则会链接到x86的库。
- **source**: 深度问题_交叉编译.md

**answer**:

sysroot包含目标系统的：
1. **头文件（/usr/include）**：编译时需要
2. **库文件（/usr/lib）**：链接时需要

如果不用sysroot：编译器会用开发机的头文件，链接器会用开发机的库，结果是x86程序不是ARM程序。

sysroot告诉编译器："去这个目录找头文件和库，不要用系统的"。

---

### proj_044
- **question**: 交叉编译遇到过什么坑？
- **tags**: `[交叉编译, 常见问题, 故障排除]`
- **difficulty**: 2
- **hint**: 四大坑：符号链接绝对路径失效 → glibc版本不匹配 → 第三方库需单独交叉编译 → Qt插件缺失。
- **source**: 深度问题_交叉编译.md

**answer**:

1. **符号链接问题** — sysroot里的.so链接是绝对路径，拷贝过来后链接失效，需要重新创建相对路径的链接

2. **版本不匹配** — 开发机gcc 9，目标设备glibc 2.17，编译出的程序跑不起来。解决：用低版本工具链

3. **第三方库** — 项目依赖OpenSSL，需要单独交叉编译OpenSSL，然后把头文件和库放到sysroot

4. **Qt插件** — Qt应用依赖平台插件（platforms/libqxcb.so），忘记部署导致程序无法启动，报错"could not find or load the Qt platform plugin"

---

### proj_045
- **question**: 如何验证编译结果是正确的架构？
- **tags**: `[架构验证, file命令, readelf]`
- **difficulty**: 1
- **hint**: 三种验证：file命令看ARM aarch64 → readelf -h看Machine字段 → 最终验证：在目标设备上运行。
- **source**: 深度问题_交叉编译.md

**answer**:

```bash
# 用file命令
file myapp  # 输出应该包含 ARM aarch64

# 用readelf
aarch64-linux-gnu-readelf -h myapp  # Machine字段应该是 AArch64

# 查看依赖的库
aarch64-linux-gnu-ldd myapp  # 应该列出ARM版本的库

# 最终验证：在目标设备上运行
./myapp --version
```

---

### proj_046
- **question**: 能不能用Docker简化交叉编译？
- **tags**: `[Docker, QEMU, CI/CD, 构建系统]`
- **difficulty**: 2
- **hint**: 三种方式：Docker+QEMU（简单但慢）→ Docker+交叉工具链（快但配置复杂，我们的CI方案）→ Buildroot/Yocto（适合定制整个系统）。
- **source**: 深度问题_交叉编译.md

**answer**:

可以，有几种方式：

1. **Docker + QEMU** — 在Docker里运行ARM环境，直接用ARM的gcc编译。慢但简单。
2. **Docker + 交叉编译工具链** — Docker里装交叉编译器，和物理机上交叉编译一样。快，但配置复杂。
3. **Buildroot/Yocto** — 完整的嵌入式Linux构建系统，自动处理工具链和依赖，适合需要定制整个系统的场景。

我们项目用的是方式2，CI服务器上有Docker镜像，包含预配置好的交叉编译环境。

---

## J. 数据采集软件设计（开放题）

### proj_047
- **question**: 如果让你设计一个软件，用于对接驱动采集数据，你会怎么设计？
- **tags**: `[系统设计, 分层架构, 模块化, 数据管线]`
- **difficulty**: 3
- **hint**: 先澄清需求（数据源/数据量/实时性/存储/平台），然后分层架构（驱动层/服务层/业务层/应用层），重点讲核心模块和线程模型。
- **source**: 深度问题_数据采集软件设计.md

**answer**:

**【需求确认】**
首先确认关键需求：数据源类型和数量、数据量大小、实时性要求、是否需要存储和处理、运行平台。

**【整体架构 — 分层设计】**
- 硬件层（传感器、采集卡、通信接口）
- 驱动层（设备驱动、协议解析、数据采集）
- 服务层（设备管理、通道管理、数据分发、配置管理）
- 业务层（数据处理、分析算法、存储管理）
- 应用层（UI显示、报警、报表）

**【核心模块设计】**

1. **设备驱动层** — 定义IDevice/IAcquisitionDevice接口，工厂模式创建设备实例
2. **数据采集层** — AcquisitionManager统一管理设备，每个设备独立线程
3. **数据处理层** — IProcessor接口+可配置处理流水线（滤波器、特征提取等）
4. **数据分发层** — 发布-订阅模式，支持多个消费者（显示/存储/报警）
5. **数据存储层** — IDataStore接口，支持二进制文件/SQLite等多种后端

**【线程模型】**
- 主线程：UI更新、用户交互
- 采集线程（每设备一个）：不互相阻塞
- 处理线程：流水线处理
- 存储线程：异步写文件
- 各线程用无锁队列连接

**【扩展性考虑】**
- 新设备只需实现接口
- 新处理器即插即用
- 配置文件驱动，无需改代码

---

### proj_048
- **question**: （数据采集设计追问）如果数据量很大怎么办？
- **tags**: `[大数据量, 降采样, 缓冲策略]`
- **difficulty**: 2
- **hint**: 四层应对：采集层增大缓冲区 → 处理层降采样/抽取关键帧 → 存储层分文件+压缩 → 显示层控频+抽稀。
- **source**: 深度问题_数据采集软件设计.md

**answer**:

1. **采集层**：增大缓冲区，允许丢帧
2. **处理层**：降采样、抽取关键帧
3. **存储层**：分文件存储、压缩
4. **显示层**：控频刷新、抽稀显示

---

### proj_049
- **question**: （数据采集设计追问）怎么保证不丢数据？
- **tags**: `[数据完整性, 队列监控, 优先级]`
- **difficulty**: 2
- **hint**: 四点保障：队列深度根据最大延迟计算 → 监控队列使用率预警 → 关键数据优先处理 → 持久化保证存储不丢。
- **source**: 深度问题_数据采集软件设计.md

**answer**:

1. 队列深度根据最大延迟计算
2. 监控队列使用率，预警
3. 关键数据优先处理
4. 持久化保证存储不丢

---

### proj_050
- **question**: （数据采集设计追问）多个设备时间怎么同步？
- **tags**: `[时间同步, 硬件触发, 时间戳对齐]`
- **difficulty**: 2
- **hint**: 三种方案：主机时间戳（简单）→ 硬件同步（外部触发信号）→ 软件对齐（时间戳就近匹配）。
- **source**: 深度问题_数据采集软件设计.md

**answer**:

1. **主机时间戳**：采集时由主机打时间戳（简单，适合精度要求不高的场景）
2. **硬件同步**：用外部触发信号（精度高，需要硬件支持）
3. **软件对齐**：根据时间戳就近匹配（折中方案）

---

## K. 项目概述与技术细节（完整面试问题清单补充）

### proj_051
- **question**: 介绍一下T95项目，你负责什么？
- **tags**: `[项目介绍, 职责范围, T95]`
- **difficulty**: 1
- **hint**: 四个方面：多检测技术集成框架设计 → TEV检测模块开发 → 红外模块快速集成 → 实时数据管线重构。
- **source**: 完整面试问题清单.md

**answer**:

T95是多功能电力设备带电检测终端，集成红外测温、UHF局放、TEV、AE等检测技术。

我负责：
1. **多检测技术集成框架设计** — 统一接口规范，支持模块热插拔
2. **TEV检测模块开发** — 1MHz采样率脉冲采集，PRPS图谱生成
3. **红外模块快速集成** — 2周完成从SDK调研到功能上线
4. **实时数据管线重构** — 解决UI刷新卡顿问题

---

### proj_052
- **question**: HTTP服务器怎么实现的？
- **tags**: `[HTTP服务器, Qt, QTcpServer, RESTful]`
- **difficulty**: 2
- **hint**: 基于QTcpServer，解析请求行（方法+路径），路由分发，JSON数据格式。
- **source**: 完整面试问题清单.md

**answer**:

基于Qt的QTcpServer实现轻量级HTTP服务器：
- 监听连接 → 读取请求 → 解析请求行（GET /api/devices HTTP/1.1）
- 路由分发：`router_.dispatch(method, path, body)`
- 返回响应：HTTP状态行 + Content-Type头 + JSON数据
- 支持的功能：GET/POST、RESTful路由、JSON数据格式

---

### proj_053
- **question**: MQTT在项目里怎么用的？
- **tags**: `[MQTT, IoT, QoS, 遗嘱消息]`
- **difficulty**: 2
- **hint**: Topic设计（status/command/alert）+ QoS选择（普通QoS0/告警QoS1）+ 遗嘱消息（异常断开自动offline）。
- **source**: 完整面试问题清单.md

**answer**:

用于设备状态监控。Broker部署在服务器，终端设备作为Client连接。

**Topic设计**：
- `/devices/{device_id}/status` — 设备状态上报（Retain）
- `/devices/{device_id}/command` — 控制指令下发
- `/devices/{device_id}/alert` — 告警消息

**QoS选择**：
- 普通状态：QoS 0（偶尔丢失可接受）
- 告警消息：QoS 1（需要送达）

**遗嘱消息**：设备异常断开时自动发布offline状态。

---

### proj_054
- **question**: 多线程框架怎么设计的？
- **tags**: `[线程模型, 线程池, 消息队列, 信号槽]`
- **difficulty**: 2
- **hint**: 三种线程分工：主线程（UI）+ 工作线程池（业务逻辑）+ IO线程（网络串口），通过消息队列和跨线程信号槽通信。
- **source**: 完整面试问题清单.md

**answer**:

**线程模型**：
```
主线程(UI) ←→ 工作线程池 ←→ IO线程
              ↑
           消息队列
```

**线程分工**：
- 主线程：UI更新、用户交互
- 工作线程池：业务逻辑处理
- IO线程：网络收发、串口读写

**通信机制**：
- 线程间用消息队列通信
- 跨线程信号槽（Qt::QueuedConnection）
