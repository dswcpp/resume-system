# 深度问题：数据采集软件设计

> 面试题：如果让你设计一个软件，用于对接驱动采集数据，你会怎么设计？

---

## 一、需求澄清

首先要问清楚需求：

| 问题 | 可能的答案 | 影响设计的点 |
|------|------------|--------------|
| 采集什么数据？ | 传感器、图像、音频... | 数据量、采样率 |
| 数据量多大？ | 1KB/s ~ 100MB/s | 缓冲、性能优化 |
| 实时性要求？ | 毫秒级、秒级 | 架构、队列深度 |
| 需要存储吗？ | 是/否 | 存储模块 |
| 需要处理吗？ | 原始/滤波/分析 | 处理流水线 |
| 有几个数据源？ | 单个/多个 | 模块化设计 |
| 运行平台？ | Windows/Linux/嵌入式 | 跨平台考虑 |

假设场景：
- 多个传感器（温度、压力、振动）
- 采样率100Hz ~ 10kHz不等
- 需要实时显示和存储
- 运行在Windows/Linux

---

## 二、整体架构

### 2.1 分层架构

```
┌─────────────────────────────────────────────────────────┐
│                     应用层                               │
│              (UI显示、报警、报表)                         │
├─────────────────────────────────────────────────────────┤
│                     业务层                               │
│         (数据处理、分析算法、存储管理)                    │
├─────────────────────────────────────────────────────────┤
│                     服务层                               │
│      (设备管理、通道管理、数据分发、配置管理)             │
├─────────────────────────────────────────────────────────┤
│                     驱动层                               │
│            (设备驱动、协议解析、数据采集)                 │
├─────────────────────────────────────────────────────────┤
│                     硬件层                               │
│              (传感器、采集卡、通信接口)                   │
└─────────────────────────────────────────────────────────┘
```

### 2.2 核心模块

```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│ 设备驱动 │───>│ 数据采集 │───>│ 数据处理 │───>│ 数据分发 │
└──────────┘    └──────────┘    └──────────┘    └──────────┘
                                                     │
                            ┌────────────────────────┼────────────────────────┐
                            │                        │                        │
                            ▼                        ▼                        ▼
                      ┌──────────┐            ┌──────────┐            ┌──────────┐
                      │  UI显示  │            │  数据存储 │            │  报警系统 │
                      └──────────┘            └──────────┘            └──────────┘
```

---

## 三、核心模块设计

### 3.1 设备驱动层

#### 设备接口抽象

```cpp
// 设备基类
class IDevice {
public:
    virtual ~IDevice() = default;
    
    // 生命周期
    virtual bool open() = 0;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;
    
    // 配置
    virtual bool configure(const DeviceConfig& config) = 0;
    virtual DeviceConfig getConfig() const = 0;
    
    // 信息
    virtual QString getName() const = 0;
    virtual QString getSerial() const = 0;
    virtual DeviceState getState() const = 0;
    
signals:
    void stateChanged(DeviceState state);
    void errorOccurred(const QString& message);
};

// 采集设备接口
class IAcquisitionDevice : public IDevice {
public:
    virtual bool startAcquisition() = 0;
    virtual void stopAcquisition() = 0;
    virtual bool isAcquiring() const = 0;
    
    // 采集参数
    virtual void setSampleRate(double rate) = 0;
    virtual double getSampleRate() const = 0;
    virtual void setChannels(const QList<int>& channels) = 0;
    
signals:
    void dataReady(const AcquisitionData& data);
};
```

#### 具体设备实现

```cpp
// 串口设备示例
class SerialDevice : public IAcquisitionDevice {
    QSerialPort serialPort_;
    FrameParser parser_;
    
public:
    bool open() override {
        serialPort_.setPortName(config_.portName);
        serialPort_.setBaudRate(config_.baudRate);
        return serialPort_.open(QIODevice::ReadWrite);
    }
    
    bool startAcquisition() override {
        // 发送开始采集命令
        QByteArray cmd = buildStartCommand();
        serialPort_.write(cmd);
        return waitAck();
    }
    
private slots:
    void onDataReceived() {
        QByteArray data = serialPort_.readAll();
        parser_.feed(data);
    }
    
    void onFrameParsed(const QByteArray& frame) {
        AcquisitionData data = parseFrame(frame);
        emit dataReady(data);
    }
};
```

#### 设备工厂

```cpp
class DeviceFactory {
    std::map<QString, std::function<IDevice*()>> creators_;
    
public:
    static DeviceFactory& instance() {
        static DeviceFactory inst;
        return inst;
    }
    
    void registerDevice(const QString& type, std::function<IDevice*()> creator) {
        creators_[type] = creator;
    }
    
    IDevice* createDevice(const QString& type) {
        auto it = creators_.find(type);
        if (it == creators_.end()) return nullptr;
        return it->second();
    }
};

// 注册设备
REGISTER_DEVICE("serial", SerialDevice)
REGISTER_DEVICE("usb", UsbDevice)
REGISTER_DEVICE("ethernet", EthernetDevice)
```

### 3.2 数据采集层

#### 数据结构定义

```cpp
struct AcquisitionData {
    int64_t timestamp;           // 时间戳（微秒）
    int channelId;               // 通道ID
    DataType type;               // 数据类型
    std::vector<double> values;  // 数据值
    
    // 元数据
    struct Metadata {
        double sampleRate;
        QString unit;
        double scale;
        double offset;
    } meta;
};

// 数据包（批量数据）
struct DataPacket {
    int64_t startTime;
    int64_t endTime;
    std::vector<AcquisitionData> samples;
    
    size_t sampleCount() const { return samples.size(); }
    double duration() const { return (endTime - startTime) / 1e6; }
};
```

#### 采集管理器

```cpp
class AcquisitionManager : public QObject {
    Q_OBJECT
    
    std::map<QString, std::unique_ptr<IAcquisitionDevice>> devices_;
    DataBuffer buffer_;
    std::atomic<bool> running_{false};
    
public:
    // 设备管理
    bool addDevice(const QString& id, const QString& type) {
        auto device = DeviceFactory::instance().createDevice(type);
        if (!device) return false;
        
        // 连接信号
        connect(device, &IAcquisitionDevice::dataReady,
                this, &AcquisitionManager::onDataReceived);
        
        devices_[id].reset(dynamic_cast<IAcquisitionDevice*>(device));
        return true;
    }
    
    void removeDevice(const QString& id) {
        devices_.erase(id);
    }
    
    // 采集控制
    bool startAll() {
        for (auto& [id, device] : devices_) {
            if (!device->open()) {
                qWarning() << "Failed to open device:" << id;
                return false;
            }
            if (!device->startAcquisition()) {
                qWarning() << "Failed to start acquisition:" << id;
                return false;
            }
        }
        running_ = true;
        return true;
    }
    
    void stopAll() {
        running_ = false;
        for (auto& [id, device] : devices_) {
            device->stopAcquisition();
            device->close();
        }
    }
    
private slots:
    void onDataReceived(const AcquisitionData& data) {
        // 加时间戳
        auto stamped = data;
        if (stamped.timestamp == 0) {
            stamped.timestamp = getCurrentTimestamp();
        }
        
        // 放入缓冲区
        buffer_.push(stamped);
        
        // 通知订阅者
        emit dataAcquired(stamped);
    }
    
signals:
    void dataAcquired(const AcquisitionData& data);
};
```

### 3.3 数据处理层

#### 处理器接口

```cpp
class IProcessor {
public:
    virtual ~IProcessor() = default;
    virtual QString getName() const = 0;
    virtual DataPacket process(const DataPacket& input) = 0;
    virtual void configure(const QVariantMap& params) = 0;
};

// 滤波器
class LowPassFilter : public IProcessor {
    double cutoffFreq_;
    std::vector<double> coefficients_;
    
public:
    QString getName() const override { return "LowPassFilter"; }
    
    void configure(const QVariantMap& params) override {
        cutoffFreq_ = params["cutoff"].toDouble();
        coefficients_ = designFilter(cutoffFreq_);
    }
    
    DataPacket process(const DataPacket& input) override {
        DataPacket output = input;
        for (auto& sample : output.samples) {
            sample.values = applyFilter(sample.values, coefficients_);
        }
        return output;
    }
};

// 特征提取
class FeatureExtractor : public IProcessor {
public:
    DataPacket process(const DataPacket& input) override {
        DataPacket output;
        output.startTime = input.startTime;
        output.endTime = input.endTime;
        
        // 计算统计特征
        AcquisitionData features;
        features.timestamp = input.startTime;
        features.values = {
            calculateMean(input),
            calculateStd(input),
            calculateMax(input),
            calculateMin(input),
            calculateRMS(input)
        };
        
        output.samples.push_back(features);
        return output;
    }
};
```

#### 处理流水线

```cpp
class ProcessingPipeline {
    std::vector<std::unique_ptr<IProcessor>> processors_;
    SPSCQueue<DataPacket, 64> inputQueue_;
    SPSCQueue<DataPacket, 64> outputQueue_;
    std::thread workerThread_;
    std::atomic<bool> running_{false};
    
public:
    void addProcessor(std::unique_ptr<IProcessor> processor) {
        processors_.push_back(std::move(processor));
    }
    
    void removeProcessor(const QString& name) {
        auto it = std::find_if(processors_.begin(), processors_.end(),
            [&](const auto& p) { return p->getName() == name; });
        if (it != processors_.end()) {
            processors_.erase(it);
        }
    }
    
    void start() {
        running_ = true;
        workerThread_ = std::thread([this]() {
            while (running_) {
                DataPacket packet;
                if (inputQueue_.pop(packet)) {
                    // 依次通过所有处理器
                    for (auto& processor : processors_) {
                        packet = processor->process(packet);
                    }
                    outputQueue_.push(packet);
                }
            }
        });
    }
    
    void stop() {
        running_ = false;
        if (workerThread_.joinable()) {
            workerThread_.join();
        }
    }
    
    void pushInput(const DataPacket& packet) {
        inputQueue_.push(packet);
    }
    
    bool popOutput(DataPacket& packet) {
        return outputQueue_.pop(packet);
    }
};
```

### 3.4 数据分发层

#### 发布-订阅模式

```cpp
class DataDistributor {
    std::map<QString, std::vector<std::function<void(const DataPacket&)>>> subscribers_;
    std::mutex mutex_;
    
public:
    // 订阅特定通道的数据
    void subscribe(const QString& channel, 
                   std::function<void(const DataPacket&)> callback) {
        std::lock_guard<std::mutex> lock(mutex_);
        subscribers_[channel].push_back(callback);
    }
    
    // 订阅所有数据
    void subscribeAll(std::function<void(const DataPacket&)> callback) {
        subscribe("*", callback);
    }
    
    // 分发数据
    void distribute(const QString& channel, const DataPacket& data) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        // 通知特定通道的订阅者
        if (subscribers_.count(channel)) {
            for (auto& cb : subscribers_[channel]) {
                cb(data);
            }
        }
        
        // 通知全局订阅者
        if (subscribers_.count("*")) {
            for (auto& cb : subscribers_["*"]) {
                cb(data);
            }
        }
    }
};
```

### 3.5 数据存储层

#### 存储接口

```cpp
class IDataStore {
public:
    virtual ~IDataStore() = default;
    
    virtual bool open(const QString& path) = 0;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;
    
    virtual bool write(const DataPacket& data) = 0;
    virtual bool read(int64_t startTime, int64_t endTime, DataPacket& data) = 0;
    
    virtual int64_t getStartTime() const = 0;
    virtual int64_t getEndTime() const = 0;
    virtual size_t getRecordCount() const = 0;
};

// 二进制文件存储
class BinaryFileStore : public IDataStore {
    QFile file_;
    QDataStream stream_;
    
public:
    bool write(const DataPacket& data) override {
        // 写入头部
        stream_ << data.startTime << data.endTime;
        stream_ << static_cast<quint32>(data.samples.size());
        
        // 写入数据
        for (const auto& sample : data.samples) {
            stream_ << sample.timestamp << sample.channelId;
            stream_ << static_cast<quint32>(sample.values.size());
            for (double v : sample.values) {
                stream_ << v;
            }
        }
        
        return stream_.status() == QDataStream::Ok;
    }
};

// SQLite存储
class SqliteStore : public IDataStore {
    QSqlDatabase db_;
    
public:
    bool write(const DataPacket& data) override {
        QSqlQuery query(db_);
        query.prepare("INSERT INTO samples (timestamp, channel, value) VALUES (?, ?, ?)");
        
        for (const auto& sample : data.samples) {
            query.bindValue(0, sample.timestamp);
            query.bindValue(1, sample.channelId);
            query.bindValue(2, QByteArray::fromRawData(
                reinterpret_cast<const char*>(sample.values.data()),
                sample.values.size() * sizeof(double)));
            query.exec();
        }
        
        return true;
    }
};
```

#### 存储管理器

```cpp
class StorageManager {
    std::unique_ptr<IDataStore> store_;
    std::queue<DataPacket> writeQueue_;
    std::mutex mutex_;
    std::thread writerThread_;
    std::atomic<bool> running_{false};
    
public:
    void setStore(std::unique_ptr<IDataStore> store) {
        store_ = std::move(store);
    }
    
    void start(const QString& path) {
        store_->open(path);
        running_ = true;
        writerThread_ = std::thread([this]() {
            while (running_) {
                DataPacket packet;
                {
                    std::lock_guard<std::mutex> lock(mutex_);
                    if (writeQueue_.empty()) continue;
                    packet = std::move(writeQueue_.front());
                    writeQueue_.pop();
                }
                store_->write(packet);
            }
        });
    }
    
    void enqueue(const DataPacket& data) {
        std::lock_guard<std::mutex> lock(mutex_);
        writeQueue_.push(data);
    }
};
```

---

## 四、线程模型

### 4.1 线程分配

```
┌────────────────┐
│    主线程      │ ── UI更新、用户交互
└───────┬────────┘
        │
        ├──────────────────────────────────────────┐
        │                                          │
┌───────▼────────┐  ┌───────────────┐  ┌──────────▼─────────┐
│  采集线程1     │  │  采集线程2    │  │    处理线程         │
│  (设备1)       │  │  (设备2)      │  │   (流水线)          │
└───────┬────────┘  └───────┬───────┘  └──────────┬─────────┘
        │                   │                     │
        └───────────────────┼─────────────────────┘
                            │
                    ┌───────▼───────┐
                    │   存储线程     │
                    │  (写文件)      │
                    └───────────────┘
```

### 4.2 线程同步

```cpp
// 使用无锁队列连接各线程
class DataFlowManager {
    // 采集→处理
    SPSCQueue<DataPacket, 64> acqToProc_;
    
    // 处理→显示
    SPSCQueue<DataPacket, 32> procToDisplay_;
    
    // 处理→存储
    SPSCQueue<DataPacket, 128> procToStore_;
    
public:
    void onDataAcquired(const DataPacket& data) {
        acqToProc_.push(data);
    }
    
    void onDataProcessed(const DataPacket& data) {
        procToDisplay_.push(data);
        procToStore_.push(data);
    }
};
```

---

## 五、配置管理

### 5.1 配置结构

```cpp
struct SystemConfig {
    // 设备配置
    struct DeviceConfig {
        QString id;
        QString type;
        QVariantMap params;  // 设备特定参数
    };
    std::vector<DeviceConfig> devices;
    
    // 采集配置
    struct AcquisitionConfig {
        double sampleRate;
        QList<int> channels;
        int bufferSize;
    } acquisition;
    
    // 处理配置
    struct ProcessingConfig {
        QStringList processors;  // 处理器列表
        QVariantMap processorParams;  // 处理器参数
    } processing;
    
    // 存储配置
    struct StorageConfig {
        QString type;  // "binary", "sqlite", "hdf5"
        QString path;
        int flushInterval;  // 刷新间隔（秒）
    } storage;
    
    // 显示配置
    struct DisplayConfig {
        int refreshRate;  // 刷新率（Hz）
        int historyLength;  // 历史长度（秒）
    } display;
};
```

### 5.2 配置加载

```cpp
class ConfigManager {
public:
    bool load(const QString& path) {
        QFile file(path);
        if (!file.open(QIODevice::ReadOnly)) return false;
        
        QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
        QJsonObject root = doc.object();
        
        // 解析设备配置
        QJsonArray devices = root["devices"].toArray();
        for (const auto& dev : devices) {
            DeviceConfig dc;
            dc.id = dev["id"].toString();
            dc.type = dev["type"].toString();
            dc.params = dev["params"].toObject().toVariantMap();
            config_.devices.push_back(dc);
        }
        
        // 解析其他配置...
        
        return true;
    }
    
    const SystemConfig& getConfig() const { return config_; }
    
private:
    SystemConfig config_;
};
```

---

## 六、错误处理

### 6.1 错误类型

```cpp
enum class ErrorCode {
    None = 0,
    DeviceNotFound,
    DeviceOpenFailed,
    DeviceDisconnected,
    DataOverflow,
    StorageFailed,
    ConfigInvalid,
    // ...
};

struct Error {
    ErrorCode code;
    QString message;
    QString source;
    int64_t timestamp;
};
```

### 6.2 错误处理策略

```cpp
class ErrorHandler {
public:
    void handleError(const Error& error) {
        // 记录日志
        qWarning() << "Error:" << error.message 
                   << "from" << error.source;
        
        // 根据错误类型处理
        switch (error.code) {
        case ErrorCode::DeviceDisconnected:
            // 尝试重连
            scheduleReconnect(error.source);
            break;
            
        case ErrorCode::DataOverflow:
            // 清理缓冲区
            clearBuffer(error.source);
            break;
            
        case ErrorCode::StorageFailed:
            // 切换备用存储
            switchToBackupStorage();
            break;
            
        default:
            break;
        }
        
        // 通知UI
        emit errorOccurred(error);
    }
    
private:
    void scheduleReconnect(const QString& deviceId) {
        QTimer::singleShot(5000, [=]() {
            // 5秒后重连
            reconnectDevice(deviceId);
        });
    }
};
```

---

## 七、面试回答模板

### 完整回答

```
【需求确认】
首先我会确认几个关键需求：数据源类型和数量、数据量大小、
实时性要求、是否需要存储和处理、运行平台。

【整体架构】
我会采用分层架构：驱动层、服务层、业务层、应用层。
各层通过接口解耦，方便扩展和测试。

【核心设计】

1. 设备驱动层
   - 定义统一的设备接口IDevice
   - 不同设备继承接口实现
   - 用工厂模式创建设备实例

2. 数据采集层
   - AcquisitionManager统一管理所有设备
   - 每个设备一个采集线程，避免互相阻塞
   - 数据打上时间戳放入队列

3. 数据处理层
   - 定义IProcessor接口
   - 支持动态配置处理流水线
   - 处理线程独立，不阻塞采集

4. 数据分发层
   - 发布-订阅模式
   - 支持多个消费者：显示、存储、报警等

5. 线程模型
   - 采集线程、处理线程、存储线程分离
   - 用无锁队列连接各线程
   - 避免锁竞争，保证实时性

【关键技术点】
- 无锁队列保证高性能
- 环形缓冲区控制内存
- 时间戳对齐保证数据同步
- 错误处理和自动恢复

【扩展性考虑】
- 新设备只需实现接口
- 新处理器即插即用
- 配置文件驱动，无需改代码
```

### 追问准备

**Q: 如果数据量很大怎么办？**
```
1. 采集层：增大缓冲区，允许丢帧
2. 处理层：降采样、抽取关键帧
3. 存储层：分文件存储、压缩
4. 显示层：控频刷新、抽稀显示
```

**Q: 怎么保证不丢数据？**
```
1. 队列深度根据最大延迟计算
2. 监控队列使用率，预警
3. 关键数据优先处理
4. 持久化保证存储不丢
```

**Q: 多个设备时间怎么同步？**
```
1. 主机时间戳：采集时由主机打时间戳
2. 硬件同步：用外部触发信号
3. 软件对齐：根据时间戳就近匹配
```
