# 深度问题：交叉编译

> 简历原文：在Ubuntu 20.04下搭建RK3399（aarch64-linux-gnu-g++）交叉编译环境

---

## 一、什么是交叉编译

### 1.1 基本概念

```
交叉编译 = 在一种平台上编译出另一种平台运行的程序

常规编译（本地编译）：
  x86电脑 ──编译──> x86程序 ──运行──> x86电脑 ✓

交叉编译：
  x86电脑 ──编译──> ARM程序 ──运行──> ARM设备 ✓
                    └──运行──> x86电脑 ✗
```

### 1.2 为什么需要交叉编译

| 情况 | 说明 |
|------|------|
| 目标设备性能弱 | ARM板编译慢，用x86电脑编译快 |
| 目标设备无法编译 | 嵌入式设备可能没有编译器 |
| 批量编译需求 | CI/CD服务器统一编译所有平台版本 |
| 开发效率 | 在熟悉的开发环境写代码、编译 |

### 1.3 核心术语

```
Host（宿主机）：运行编译器的机器，如x86 Ubuntu
Target（目标机）：运行编译结果的机器，如ARM RK3399
Toolchain（工具链）：交叉编译器及配套工具的集合
Sysroot：目标系统的根文件系统副本，包含头文件和库
```

---

## 二、交叉编译工具链

### 2.1 工具链组成

```
aarch64-linux-gnu-gcc      # C编译器
aarch64-linux-gnu-g++      # C++编译器
aarch64-linux-gnu-ld       # 链接器
aarch64-linux-gnu-ar       # 静态库打包
aarch64-linux-gnu-strip    # 去除调试符号
aarch64-linux-gnu-objdump  # 反汇编
aarch64-linux-gnu-gdb      # 调试器
```

命名规则：`架构-厂商-系统-工具`
- `aarch64`：64位ARM架构
- `linux`：Linux系统
- `gnu`：使用GNU C库（glibc）

### 2.2 获取工具链

```bash
# 方式一：包管理器安装（推荐）
sudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

# 方式二：从Linaro下载
wget https://releases.linaro.org/components/toolchain/binaries/latest/aarch64-linux-gnu/gcc-linaro-xxx-aarch64-linux-gnu.tar.xz

# 方式三：厂商提供（如RK3399的SDK）
# 通常在SDK的prebuilts目录下
```

### 2.3 验证工具链

```bash
# 查看版本
aarch64-linux-gnu-g++ --version

# 编译测试程序
echo 'int main() { return 0; }' > test.cpp
aarch64-linux-gnu-g++ test.cpp -o test

# 查看编译结果
file test
# 输出：test: ELF 64-bit LSB executable, ARM aarch64, ...
```

---

## 三、搭建Qt交叉编译环境

### 3.1 整体步骤

```
1. 安装交叉编译工具链
2. 获取目标系统的sysroot
3. 配置Qt交叉编译
4. 编译Qt源码
5. 配置Qt Creator
```

### 3.2 步骤一：安装工具链

```bash
# 安装编译器
sudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

# 安装编译依赖
sudo apt install make cmake pkg-config
sudo apt install libgl1-mesa-dev  # OpenGL头文件
```

### 3.3 步骤二：准备sysroot

sysroot包含目标系统的头文件和库，有两种获取方式：

**方式一：从目标设备拷贝**

```bash
# 在目标设备上
tar czf sysroot.tar.gz /usr/include /usr/lib /lib

# 拷贝到开发机
scp user@target:/path/sysroot.tar.gz .

# 解压
mkdir -p ~/rk3399-sysroot
tar xzf sysroot.tar.gz -C ~/rk3399-sysroot
```

**方式二：使用SDK提供的**

```bash
# RK3399 SDK通常有现成的
cd ~/rk3399-sdk/prebuilts/
ls sysroot/
```

### 3.4 步骤三：配置Qt

创建Qt的mkspec配置文件：

```bash
# 在Qt源码目录下创建
mkdir -p qtbase/mkspecs/linux-aarch64-gnu-g++
```

创建 `qmake.conf`：

```makefile
# qtbase/mkspecs/linux-aarch64-gnu-g++/qmake.conf

include(../common/linux.conf)
include(../common/gcc-base-unix.conf)
include(../common/g++-unix.conf)

# 编译器路径
QMAKE_CC                = aarch64-linux-gnu-gcc
QMAKE_CXX               = aarch64-linux-gnu-g++
QMAKE_LINK              = aarch64-linux-gnu-g++
QMAKE_LINK_SHLIB        = aarch64-linux-gnu-g++

# 其他工具
QMAKE_AR                = aarch64-linux-gnu-ar cqs
QMAKE_OBJCOPY           = aarch64-linux-gnu-objcopy
QMAKE_NM                = aarch64-linux-gnu-nm -P
QMAKE_STRIP             = aarch64-linux-gnu-strip

load(qt_config)
```

创建 `qplatformdefs.h`：

```cpp
// qtbase/mkspecs/linux-aarch64-gnu-g++/qplatformdefs.h
#include "../linux-g++/qplatformdefs.h"
```

### 3.5 步骤四：编译Qt

```bash
# 进入Qt源码目录
cd qt-everywhere-src-5.15.2

# 配置
./configure \
    -prefix /opt/qt5-arm \
    -xplatform linux-aarch64-gnu-g++ \
    -sysroot ~/rk3399-sysroot \
    -opensource -confirm-license \
    -nomake examples -nomake tests \
    -no-opengl \  # 或 -opengl es2 如果需要
    -skip qtwebengine  # 跳过不需要的模块

# 编译（-j8表示8线程，根据CPU调整）
make -j8

# 安装
make install
```

### 3.6 步骤五：配置Qt Creator

在Qt Creator中：

1. **添加Qt版本**
   - Tools → Options → Kits → Qt Versions
   - Add → 选择 `/opt/qt5-arm/bin/qmake`

2. **添加编译器**
   - Tools → Options → Kits → Compilers
   - Add → GCC → C++ → 选择 `aarch64-linux-gnu-g++`

3. **添加Kit**
   - Tools → Options → Kits → Kits
   - Add → 选择刚才添加的Qt版本和编译器
   - Sysroot → 选择 `~/rk3399-sysroot`

---

## 四、常见问题及解决

### 4.1 找不到头文件

```
错误：fatal error: xxx.h: No such file or directory
```

原因：sysroot中缺少头文件

解决：
```bash
# 方法一：从目标设备拷贝
scp user@target:/usr/include/xxx.h ~/rk3399-sysroot/usr/include/

# 方法二：安装对应的开发包到sysroot
# （如果有目标架构的包源）
apt download libxxx-dev:arm64
dpkg -x libxxx-dev_xxx_arm64.deb ~/rk3399-sysroot/
```

### 4.2 链接错误：找不到库

```
错误：cannot find -lxxx
```

解决：
```bash
# 检查库是否存在
ls ~/rk3399-sysroot/usr/lib/libxxx.so

# 如果不存在，从目标设备拷贝
scp user@target:/usr/lib/libxxx.so* ~/rk3399-sysroot/usr/lib/

# 修复符号链接
cd ~/rk3399-sysroot/usr/lib/
ln -sf libxxx.so.1.0 libxxx.so
```

### 4.3 运行时找不到库

```
错误：error while loading shared libraries: libxxx.so: cannot open shared object file
```

程序能编译但在目标设备上运行报错。

解决：
```bash
# 方法一：把库拷贝到目标设备
scp libxxx.so user@target:/usr/lib/
ssh user@target ldconfig

# 方法二：静态链接
LIBS += -Wl,-Bstatic -lxxx -Wl,-Bdynamic

# 方法三：设置rpath
QMAKE_LFLAGS += -Wl,-rpath,/opt/myapp/lib
```

### 4.4 glibc版本不匹配

```
错误：version `GLIBC_2.28' not found
```

原因：开发机的glibc版本高于目标设备

解决：
```bash
# 检查glibc版本
aarch64-linux-gnu-gcc -print-file-name=libc.so.6 | xargs strings | grep GLIBC

# 方法一：使用目标设备的工具链
# （从SDK获取或自己编译低版本gcc）

# 方法二：使用静态链接
# （不推荐，glibc静态链接有问题）

# 方法三：升级目标设备系统
```

### 4.5 架构不匹配

```
错误：cannot execute binary file: Exec format error
```

原因：在x86机器上运行了ARM程序

验证：
```bash
file ./myapp
# 应该显示 ARM aarch64，如果是 x86-64 说明编译配置有问题
```

---

## 五、项目实践

### 5.1 CMake交叉编译配置

```cmake
# toolchain-aarch64.cmake

set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

# 工具链
set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)

# sysroot
set(CMAKE_SYSROOT /home/user/rk3399-sysroot)
set(CMAKE_FIND_ROOT_PATH /home/user/rk3399-sysroot)

# 查找配置
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

# Qt路径
set(Qt5_DIR /opt/qt5-arm/lib/cmake/Qt5)
```

使用：
```bash
mkdir build && cd build
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchain-aarch64.cmake ..
make
```

### 5.2 qmake交叉编译

```bash
# 使用交叉编译的qmake
/opt/qt5-arm/bin/qmake myproject.pro
make
```

### 5.3 部署到目标设备

```bash
# 打包程序和依赖库
mkdir -p deploy/lib
cp myapp deploy/
cp /opt/qt5-arm/lib/libQt5*.so.5 deploy/lib/

# 创建启动脚本
cat > deploy/run.sh << 'EOF'
#!/bin/bash
DIR=$(dirname $(readlink -f $0))
export LD_LIBRARY_PATH=$DIR/lib:$LD_LIBRARY_PATH
$DIR/myapp "$@"
EOF
chmod +x deploy/run.sh

# 传输到目标设备
scp -r deploy/ user@target:/opt/myapp/

# 在目标设备上运行
ssh user@target /opt/myapp/run.sh
```

---

## 六、调试交叉编译的程序

### 6.1 远程GDB调试

```bash
# 在目标设备上运行gdbserver
gdbserver :1234 /opt/myapp/myapp

# 在开发机上运行gdb
aarch64-linux-gnu-gdb myapp
(gdb) target remote 192.168.1.100:1234
(gdb) break main
(gdb) continue
```

### 6.2 Qt Creator远程调试

配置步骤：
1. Tools → Options → Devices → Add → Generic Linux Device
2. 填写目标设备IP、用户名、SSH密钥
3. 在Kit中选择该设备
4. Run → Start Debugging

### 6.3 日志调试

```cpp
// 交叉编译时添加调试日志
#ifdef DEBUG_BUILD
#define LOG(fmt, ...) fprintf(stderr, "[%s:%d] " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#else
#define LOG(fmt, ...)
#endif
```

---

## 七、面试追问准备

### Q1: 交叉编译和本地编译有什么区别？

```
编译器不同：
- 本地编译：gcc生成x86代码
- 交叉编译：aarch64-linux-gnu-gcc生成ARM代码

查找路径不同：
- 本地编译：在/usr/include、/usr/lib查找
- 交叉编译：在sysroot下查找

运行方式不同：
- 本地编译：直接运行
- 交叉编译：需要传到目标设备运行

调试方式不同：
- 本地编译：直接gdb
- 交叉编译：需要gdbserver远程调试
```

### Q2: 为什么需要sysroot？

```
sysroot包含目标系统的：
1. 头文件（/usr/include）：编译时需要
2. 库文件（/usr/lib）：链接时需要

如果不用sysroot：
- 编译器会用开发机的头文件
- 链接器会用开发机的库
- 结果是x86程序，不是ARM程序

sysroot告诉编译器：
"去这个目录找头文件和库，不要用系统的"
```

### Q3: 遇到过什么坑？

```
1. 符号链接问题
   - sysroot里的.so链接是绝对路径
   - 拷贝过来后链接失效
   - 需要重新创建相对路径的链接

2. 版本不匹配
   - 开发机gcc 9，目标设备glibc 2.17
   - 编译出的程序跑不起来
   - 解决：用低版本工具链

3. 第三方库
   - 项目依赖OpenSSL
   - 需要单独交叉编译OpenSSL
   - 然后把头文件和库放到sysroot
   
4. Qt插件
   - Qt应用依赖平台插件（platforms/libqxcb.so）
   - 忘记部署导致程序无法启动
   - 报错 "could not find or load the Qt platform plugin"
```

### Q4: 如何验证编译结果是正确的架构？

```bash
# 用file命令
file myapp
# 输出应该包含 ARM aarch64

# 用readelf
aarch64-linux-gnu-readelf -h myapp
# Machine字段应该是 AArch64

# 查看依赖的库
aarch64-linux-gnu-ldd myapp
# 应该列出ARM版本的库

# 最终验证：在目标设备上运行
./myapp --version
```

### Q5: 能不能用Docker简化交叉编译？

```
可以，有几种方式：

1. Docker + QEMU
   - 在Docker里运行ARM环境
   - 直接用ARM的gcc编译
   - 慢，但简单

2. Docker + 交叉编译工具链
   - Docker里装交叉编译器
   - 和物理机上交叉编译一样
   - 快，但配置复杂

3. Buildroot/Yocto
   - 完整的嵌入式Linux构建系统
   - 自动处理工具链和依赖
   - 适合需要定制整个系统的场景

我们项目用的是方式2，CI服务器上有Docker镜像，
包含预配置好的交叉编译环境。
```
