# 深度问题：如何从3个月缩短至6周

> 简历原文：设计统一的检测模块接口规范，新检测技术集成周期从3个月缩短至6周

---

## 一、问题背景

### 1.1 原来的情况

T95手持终端需要集成多种检测模块：
- 红外测温
- UHF超高频局放
- TEV暂态地电压
- AE声发射
- 未来还有更多...

**原来接入一个新模块需要3个月**：

```
第1个月：理解SDK和协议
  - 读文档、跑demo
  - 理解数据格式
  
第2个月：写代码
  - 从零开始写采集、处理、显示
  - 和主程序集成
  - 处理各种边界情况
  
第3个月：联调测试
  - 和其他模块一起跑
  - 修复冲突和bug
  - 现场测试
```

### 1.2 问题分析

为什么慢？

| 问题 | 说明 |
|------|------|
| **重复造轮子** | 每个模块都写一套：连接管理、数据解析、错误处理、日志记录 |
| **代码风格不一** | 不同人写的代码结构不同，后续维护困难 |
| **集成困难** | 没有统一接口，每次集成都要改主程序 |
| **测试不足** | 没有统一的测试框架，很多bug到现场才发现 |

---

## 二、解决方案：模块化框架

### 2.1 核心思想

```
定义统一的模块接口，新模块只需实现接口，无需关心主程序
```

### 2.2 接口设计

```cpp
// 检测模块基类
class IDetectionModule {
public:
    virtual ~IDetectionModule() = default;
    
    // ========== 生命周期 ==========
    // 初始化，返回是否成功
    virtual bool initialize() = 0;
    
    // 释放资源
    virtual void shutdown() = 0;
    
    // ========== 连接管理 ==========
    // 连接设备
    virtual bool connect() = 0;
    
    // 断开连接
    virtual void disconnect() = 0;
    
    // 获取连接状态
    virtual ConnectionState getConnectionState() const = 0;
    
    // ========== 数据采集 ==========
    // 开始采集
    virtual bool startAcquisition() = 0;
    
    // 停止采集
    virtual void stopAcquisition() = 0;
    
    // 是否正在采集
    virtual bool isAcquiring() const = 0;
    
    // ========== 信息查询 ==========
    // 模块类型
    virtual ModuleType getType() const = 0;
    
    // 模块名称（用于显示）
    virtual QString getName() const = 0;
    
    // 模块版本
    virtual QString getVersion() const = 0;
    
signals:
    // 数据就绪信号
    void dataReady(const DataPacketPtr& packet);
    
    // 连接状态变化信号
    void connectionStateChanged(ConnectionState state);
    
    // 错误信号
    void errorOccurred(const QString& message);
};
```

### 2.3 模块注册机制

```cpp
// 模块工厂
class ModuleFactory {
    using CreateFunc = std::function<IDetectionModule*()>;
    std::map<ModuleType, CreateFunc> creators_;
    
public:
    // 注册模块
    void registerModule(ModuleType type, CreateFunc creator) {
        creators_[type] = creator;
    }
    
    // 创建模块
    IDetectionModule* createModule(ModuleType type) {
        auto it = creators_.find(type);
        if (it == creators_.end()) return nullptr;
        return it->second();
    }
    
    // 获取所有已注册的模块类型
    std::vector<ModuleType> getRegisteredTypes() const {
        std::vector<ModuleType> types;
        for (const auto& [type, _] : creators_) {
            types.push_back(type);
        }
        return types;
    }
};

// 使用宏简化注册
#define REGISTER_MODULE(Type, Class) \
    static bool _registered_##Class = []() { \
        ModuleFactory::instance().registerModule(Type, []() { \
            return new Class(); \
        }); \
        return true; \
    }();

// 模块实现文件中
REGISTER_MODULE(ModuleType::TEV, TevModule)
REGISTER_MODULE(ModuleType::UHF, UhfModule)
REGISTER_MODULE(ModuleType::IR, IrModule)
```

### 2.4 模块管理器

```cpp
class ModuleManager : public QObject {
    Q_OBJECT
    
    std::map<ModuleType, std::unique_ptr<IDetectionModule>> modules_;
    
public:
    // 加载模块
    bool loadModule(ModuleType type) {
        auto module = ModuleFactory::instance().createModule(type);
        if (!module) {
            qWarning() << "Unknown module type:" << static_cast<int>(type);
            return false;
        }
        
        // 连接信号
        connect(module, &IDetectionModule::dataReady,
                this, &ModuleManager::onModuleDataReady);
        connect(module, &IDetectionModule::connectionStateChanged,
                this, &ModuleManager::onModuleStateChanged);
        connect(module, &IDetectionModule::errorOccurred,
                this, &ModuleManager::onModuleError);
        
        // 初始化
        if (!module->initialize()) {
            qWarning() << "Failed to initialize module:" << module->getName();
            delete module;
            return false;
        }
        
        modules_[type].reset(module);
        return true;
    }
    
    // 卸载模块
    void unloadModule(ModuleType type) {
        auto it = modules_.find(type);
        if (it != modules_.end()) {
            it->second->shutdown();
            modules_.erase(it);
        }
    }
    
    // 获取模块
    IDetectionModule* getModule(ModuleType type) {
        auto it = modules_.find(type);
        return it != modules_.end() ? it->second.get() : nullptr;
    }
    
    // 连接所有模块
    void connectAll() {
        for (auto& [type, module] : modules_) {
            module->connect();
        }
    }
    
private slots:
    void onModuleDataReady(const DataPacketPtr& packet) {
        // 统一处理所有模块的数据
        emit dataReady(packet);
    }
    
    void onModuleStateChanged(ConnectionState state) {
        auto module = qobject_cast<IDetectionModule*>(sender());
        emit moduleStateChanged(module->getType(), state);
    }
    
signals:
    void dataReady(const DataPacketPtr& packet);
    void moduleStateChanged(ModuleType type, ConnectionState state);
};
```

---

## 三、基础设施复用

### 3.1 连接状态机（通用）

```cpp
// 所有模块复用同一套状态机逻辑
class ConnectionStateMachine {
    ConnectionState state_ = ConnectionState::Disconnected;
    QTimer* timeoutTimer_;
    int retryCount_ = 0;
    
public:
    void handleEvent(ConnectionEvent event) {
        switch (state_) {
        case ConnectionState::Disconnected:
            if (event == ConnectionEvent::Connect) {
                state_ = ConnectionState::Connecting;
                timeoutTimer_->start(5000);  // 5秒超时
                emit stateChanged(state_);
                emit doConnect();  // 让具体模块执行连接
            }
            break;
            
        case ConnectionState::Connecting:
            if (event == ConnectionEvent::Connected) {
                timeoutTimer_->stop();
                state_ = ConnectionState::Initializing;
                emit stateChanged(state_);
                emit doInitialize();  // 让具体模块执行初始化
            } else if (event == ConnectionEvent::Timeout ||
                       event == ConnectionEvent::Error) {
                timeoutTimer_->stop();
                if (retryCount_++ < 3) {
                    emit doConnect();  // 重试
                } else {
                    state_ = ConnectionState::Disconnected;
                    retryCount_ = 0;
                    emit stateChanged(state_);
                    emit connectFailed("连接超时");
                }
            }
            break;
            
        // ... 其他状态
        }
    }
    
signals:
    void stateChanged(ConnectionState state);
    void doConnect();
    void doInitialize();
    void connectFailed(const QString& reason);
};
```

### 3.2 协议解析框架（通用）

```cpp
// 通用帧解析器
class FrameParser {
    enum class State { WaitHeader, WaitLength, WaitData, WaitChecksum };
    State state_ = State::WaitHeader;
    QByteArray buffer_;
    
    FrameConfig config_;  // 帧格式配置
    
public:
    // 配置帧格式
    void setConfig(const FrameConfig& config) {
        config_ = config;
    }
    
    // 输入数据
    void feed(const QByteArray& data) {
        buffer_.append(data);
        parse();
    }
    
private:
    void parse() {
        while (buffer_.size() > 0) {
            switch (state_) {
            case State::WaitHeader:
                // 查找帧头
                int headerPos = findHeader(buffer_, config_.header);
                if (headerPos < 0) {
                    buffer_.clear();
                    return;
                }
                buffer_.remove(0, headerPos);
                state_ = State::WaitLength;
                break;
                
            // ... 其他状态
            }
        }
    }
    
signals:
    void frameReceived(const QByteArray& frame);
    void checksumError();
};
```

### 3.3 数据处理管线（通用）

```cpp
// 数据处理管线
class DataPipeline {
    std::vector<std::unique_ptr<IProcessor>> processors_;
    SPSCQueue<DataPacketPtr, 128> inputQueue_;
    SPSCQueue<DataPacketPtr, 128> outputQueue_;
    std::thread workerThread_;
    
public:
    // 添加处理器
    void addProcessor(std::unique_ptr<IProcessor> processor) {
        processors_.push_back(std::move(processor));
    }
    
    // 输入数据
    void push(const DataPacketPtr& packet) {
        inputQueue_.push(packet);
    }
    
private:
    void workerLoop() {
        while (running_) {
            DataPacketPtr packet;
            if (inputQueue_.pop(packet)) {
                // 依次通过所有处理器
                for (auto& processor : processors_) {
                    packet = processor->process(packet);
                    if (!packet) break;  // 处理器可以丢弃数据
                }
                if (packet) {
                    outputQueue_.push(packet);
                }
            }
        }
    }
};
```

---

## 四、新模块接入流程

### 4.1 原来（3个月）

```
1. 研究SDK（2周）
2. 写连接管理（1周）
3. 写协议解析（2周）
4. 写数据处理（2周）
5. 写UI显示（2周）
6. 集成到主程序（1周）
7. 联调测试（2周）
8. 现场测试修bug（2周）
合计：14周 ≈ 3个月
```

### 4.2 现在（6周）

```
1. 研究SDK（1周）
   - 只需关注核心API
   - 参考其他模块的接入文档
   
2. 实现模块接口（2周）
   - 继承IDetectionModule
   - 实现connect/disconnect/startAcquisition等方法
   - 复用ConnectionStateMachine
   - 复用FrameParser
   
3. 配置数据处理（1周）
   - 定义数据格式
   - 配置处理管线
   - 复用现有处理器或写新处理器
   
4. 配置UI（1周）
   - 复用通用显示控件
   - 只需配置显示参数
   
5. 测试（1周）
   - 运行统一测试框架
   - 修复问题
   
合计：6周
```

### 4.3 对比

| 项目 | 原来 | 现在 | 节省 |
|------|------|------|------|
| 连接管理 | 1周 | 复用 | 1周 |
| 协议解析 | 2周 | 配置化 | 1.5周 |
| 数据处理 | 2周 | 管线配置 | 1周 |
| UI显示 | 2周 | 控件复用 | 1周 |
| 集成 | 1周 | 自动注册 | 1周 |
| 测试 | 2周 | 统一框架 | 1周 |
| **总计** | **14周** | **6周** | **8周** |

---

## 五、实际案例：红外模块接入

### 5.1 第一周：研究SDK

```cpp
// SDK核心API（理解这几个就够了）
IR_Init();                          // 初始化
IR_OpenDevice(int index);           // 打开设备
IR_SetCallback(handle, callback);   // 设置回调
IR_StartCapture(handle);            // 开始采集
IR_StopCapture(handle);             // 停止采集
IR_CloseDevice(handle);             // 关闭设备
```

### 5.2 第二周：实现模块接口

```cpp
class IrModule : public IDetectionModule {
    HANDLE device_ = nullptr;
    ConnectionStateMachine stateMachine_;  // 复用
    
public:
    bool initialize() override {
        IR_Init();
        
        // 连接状态机信号
        connect(&stateMachine_, &ConnectionStateMachine::doConnect,
                this, &IrModule::doConnect);
        connect(&stateMachine_, &ConnectionStateMachine::doInitialize,
                this, &IrModule::doInitialize);
                
        return true;
    }
    
    bool connect() override {
        stateMachine_.handleEvent(ConnectionEvent::Connect);
        return true;
    }
    
private slots:
    void doConnect() {
        device_ = IR_OpenDevice(0);
        if (device_) {
            IR_SetCallback(device_, onFrame, this);
            stateMachine_.handleEvent(ConnectionEvent::Connected);
        } else {
            stateMachine_.handleEvent(ConnectionEvent::Error);
        }
    }
    
    void doInitialize() {
        // 红外模块不需要额外初始化
        stateMachine_.handleEvent(ConnectionEvent::InitSuccess);
    }
    
    static void onFrame(void* ctx, IRFrame* frame) {
        auto self = static_cast<IrModule*>(ctx);
        auto packet = std::make_shared<DataPacket>();
        packet->timestamp = QDateTime::currentMSecsSinceEpoch();
        packet->source = ModuleType::IR;
        // 转换数据格式...
        emit self->dataReady(packet);
    }
};

REGISTER_MODULE(ModuleType::IR, IrModule)
```

### 5.3 第三周：数据处理

```cpp
// 只需配置处理管线
void IrModule::setupPipeline() {
    pipeline_.addProcessor(std::make_unique<TimestampProcessor>());  // 通用
    pipeline_.addProcessor(std::make_unique<IrColorMapper>(palette_));  // 专用
    pipeline_.addProcessor(std::make_unique<MaxTempTracker>());  // 专用
}
```

### 5.4 第四周：UI配置

```cpp
// 复用通用图像显示控件
auto irWidget = new ImageDisplayWidget();
irWidget->setColorBar(true);
irWidget->setOverlay(new TempOverlay());  // 温度标注
```

### 5.5 第五周：测试

```cpp
// 统一测试框架
class ModuleTest : public QObject {
    Q_OBJECT
    
private slots:
    void testConnect() {
        IrModule module;
        module.initialize();
        
        QSignalSpy spy(&module, &IDetectionModule::connectionStateChanged);
        module.connect();
        
        QVERIFY(spy.wait(5000));
        QCOMPARE(module.getConnectionState(), ConnectionState::Ready);
    }
    
    void testAcquisition() {
        // ...
    }
};
```

---

## 六、面试追问准备

### Q1: 接口设计时怎么考虑的？

```
主要考虑三点：

1. 最小化接口
   - 只定义必须的方法，不过度设计
   - 具体模块可以有自己的扩展接口

2. 生命周期管理
   - initialize/shutdown：资源申请释放
   - connect/disconnect：设备连接
   - start/stop：数据采集
   - 三层分离，状态清晰

3. 信号通知
   - 数据就绪、状态变化、错误发生
   - 用Qt信号槽，异步解耦
```

### Q2: 遇到不符合接口的模块怎么办？

```
用适配器模式。

比如某个SDK的回调机制和我们不一样：
class LegacyModuleAdapter : public IDetectionModule {
    LegacySDK sdk_;  // 封装原有SDK
    
    bool connect() override {
        // 把我们的接口适配到SDK的调用方式
        return sdk_.Open() && sdk_.Configure(config_);
    }
    // ...
};

设计时预留了这种灵活性。
```

### Q3: 怎么保证模块间不互相影响？

```
1. 隔离：每个模块独立的线程、独立的数据队列
2. 接口：只通过IDetectionModule接口通信
3. 无全局状态：不使用全局变量
4. 错误隔离：一个模块出错不影响其他模块

实测：关闭TEV模块时，红外模块照常工作。
```

### Q4: 6周是怎么估算的？

```
根据实际数据：
- 红外模块：首个用新框架接入，5周
- AE模块：第二个接入，4周
- 后续模块：稳定在4-6周

6周是保守估计，包含一些buffer。
比不用框架的3个月（14周）节省了8周。
```
