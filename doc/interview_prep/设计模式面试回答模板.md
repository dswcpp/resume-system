# 设计模式面试回答模板（状态机 / 生产者-消费者 / 观察者 / 工厂 / 单例）

## 1️⃣ 状态机模式

### 高频问法

- 了解状态机/状态模式吗？
- 项目里怎么用的？

### 一句话定义

> 把“状态 + 事件 → 行为 + 下一个状态”显式建模，用状态 + 转换表代替复杂 if/switch，流程清晰、可维护。

### 典型场景

- 设备连接：Idle / Connecting / Connected / Reconnecting / Error
- 协议解析：等待帧头 / 收长度 / 收数据 / 校验
- UI 流程：登录 / 验证 / 成功 / 失败

### 项目回答模板

在带电检测终端里，我在红外/通信模块的连接管理中使用状态机：
- 划分状态：`Idle`、`Connecting`、`Connected`、`Reconnecting`、`Error`。
- 事件：点击“连接”、连接成功、超时、心跳失败等。
- 以表驱动“(状态, 事件) → (动作, 下一状态)”，动作执行打开串口、启动心跳、记录日志、更新 UI。
- 原先分散的 if/else 收敛到状态机，调试只看状态序列；新增“升级模式”仅增表项即可。

### 加分点

- 先画状态图再实现，避免状态过碎/过粗。
- 为关键状态设计超时回退，防止卡死。

---

## 2️⃣ 生产者-消费者模式

### 高频问法

- 多线程数据处理怎么设计？
- 哪里用过生产者-消费者？

### 一句话定义

> 用线程安全队列解耦生产与消费，解决不同处理速度、缓冲与削峰的问题。

### 典型场景

- 采集线程 → 处理线程
- 网络接收线程 → 业务处理线程
- 日志、任务队列、线程池

### 项目回答模板

在带电检测终端的“采集→预处理→分析→显示”流水线中：
- 采集线程生产数据块，入队；
- 一个或多个处理线程消费队列，做滤波、FFT、PRPS；
- 结果再通过队列/信号槽到 UI。
- 初始实现：`std::queue + mutex + condition_variable`；热点路径改为 SPSC 无锁环形队列，`std::atomic` 管理读写索引，零拷贝、无锁，延迟/CPU 占用下降。
- 队列起到缓冲与削峰，稳定系统。

### 加分点

- 队列满：丢旧保新/降采样/降级处理。
- 用 SPSC/MPSC 环形队列优化性能。

---

## 3️⃣ 观察者模式

### 高频问法

- 什么是观察者模式？
- 项目中如何使用？

### 一句话定义

> 被观察者状态变化时自动通知订阅者，典型“一对多”依赖，实现松耦合事件通知。

### 典型场景

- Qt 的 signal/slot
- 配置变化通知多个模块
- 日志、事件总线、UI 事件订阅

### 项目回答模板

Qt 信号槽本质是观察者：
- 设备数据模块作为被观察者，发“数据更新”“连接状态变化”“告警”等信号；
- UI、日志、告警模块分别订阅所需信号；
- 数据模块不关心具体订阅者，模块解耦；新增“后台记录 PRPS 特征”仅连接信号槽即可，符合开闭原则。

### 加分点

- 也可用 `std::function` + 回调列表实现自定义观察者。
- 避免忘记解绑导致悬空回调（Qt 的 `QObject` 生命周期管理有帮助）。

---

## 4️⃣ 工厂模式

### 高频问法

- 工厂模式做什么？
- 根据类型创建对象的做法？

### 一句话定义

> 将“创建对象的逻辑”集中，根据参数/类型创建不同子类，对外暴露统一接口，创建与使用解耦。

### 典型场景

- 按设备类型创建不同 `DeviceHandler`
- 按协议类型创建不同 `Parser`/`Codec`
- 按数据库类型创建不同 `DbConnection`

### 项目回答模板

用于设备/协议适配：
- 定义抽象接口 `IDeviceHandler`（连接/断开/开始检测/读取状态）。
- 针对不同型号实现 `T95Handler`、`LegacyDeviceHandler` 等。
- 通过工厂函数返回 `std::unique_ptr<IDeviceHandler>`，调用方仅依赖接口：
```
std::unique_ptr<IDeviceHandler> createHandler(DeviceType type);
```
- 新增设备仅需“新增派生类 + 在工厂注册”，业务代码基本不动。

### 加分点

- 搭配配置/反射/注册表 `map<string, creator>` 更灵活。
- 有利于单元测试，可替换为 Mock。

---

## 5️⃣ 单例模式

### 高频问法

- 什么是单例？
- 如何实现线程安全单例？
- 用过哪些场景？

### 一句话定义

> 进程内仅一个实例，并提供全局访问点；用于全局共享资源管理（日志、配置、线程池）。

### 典型场景

- 全局日志器
- 配置管理器
- 设备管理中心
- 线程池/任务调度器

### 推荐实现（C++11）

函数内局部静态变量（线程安全初始化）：
```
class ConfigManager {
public:
    static ConfigManager& instance() {
        static ConfigManager inst;
        return inst;
    }
private:
    ConfigManager() = default;
    ConfigManager(const ConfigManager&) = delete;
    ConfigManager& operator=(const ConfigManager&) = delete;
};
```

### 项目回答模板

克制使用单例，仅在全局唯一且生命周期等于程序生命周期时使用：
- 日志器需全局可用且唯一输出通道；
- 配置管理读取一次、全局缓存。
- 使用函数内静态对象，禁止拷贝/赋值，确保唯一；强调可测试性优先，必要时改为依赖注入而非滥用单例。

### 加分点

- 单例易演变为全局变量，增加耦合、影响测试；设计时限制使用范围，仅给确需全局唯一的对象。

---

## ✅ 综合回答（面试时间充裕时用）

> 我不会为了用模式而用模式，而是在合适的问题自然使用常见模式。连接与异常恢复用状态机，表驱动“状态+事件→行为+下一个状态”；多线程架构大量用生产者-消费者，用线程安全队列解耦采集与处理，并在热点路径用无锁环形队列优化；Qt 的信号槽是观察者，数据模块与 UI/日志等解耦，新增观察者只需连信号槽；设备与协议适配用工厂模式，通过统一接口与工厂函数按类型创建不同实现，新增设备无需改动业务；单例用于日志器与配置管理这类全局唯一资源，采用 C++11 局部静态写法保证线程安全，同时控制单例数量避免全局状态泛滥。整体目标是用这些模式理清结构、降低耦合、提升可维护性与可扩展性。