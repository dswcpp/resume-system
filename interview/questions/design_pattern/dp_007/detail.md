# 事件驱动架构的优缺点？和多线程模型怎么取舍？

## 知识点速览

事件驱动架构（Event-Driven Architecture）的核心是一个**事件循环**：程序在单线程中不断监听事件（I/O就绪、定时器到期、用户操作），事件到来时调用对应的回调函数处理。典型实现有 Linux 的 epoll、Qt 的事件循环、Node.js 的 libuv。

**事件驱动 vs 多线程对比：**

| 维度 | 事件驱动 | 多线程 |
|------|---------|-------|
| 并发方式 | 单线程 + 事件循环 | 多线程并行执行 |
| 内存开销 | 低（无线程栈） | 高（每线程约1MB栈） |
| CPU利用 | 适合I/O密集 | 适合CPU密集 |
| 编程复杂度 | 回调嵌套（回调地狱） | 锁竞争、死锁风险 |
| 调试难度 | 相对简单 | 竞态条件难复现 |
| 伸缩性 | 轻松万级连接 | 受线程数限制 |

**选择依据：** 资源受限选事件驱动；CPU密集选多线程；大多数实际场景是混合模型——事件驱动主循环 + 工作线程池处理耗时任务。

## 我的实战经历

**公司/项目：** 江苏思行达 · 营业厅柜外交互终端（RK3399 ARM平台）

**问题背景：** 营业厅终端的HTTP服务器需要同时处理多个客户端的请求（前端页面、管理后台、设备状态查询等）。初版使用每连接一线程模型，在ARM平台上连接数一多内存直接吃紧——每个线程默认1MB栈空间，50个连接就要50MB，对于512MB内存的嵌入式设备来说非常浪费。

**解决方案：** 将HTTP服务器改为事件驱动模型：

- 使用 epoll 监听所有Socket的I/O事件
- 所有连接在同一个线程中通过非阻塞I/O处理
- 耗时操作（如数据库查询）才丢给工作线程池

```cpp
// 事件循环核心逻辑（简化）
while (running_) {
    int n = epoll_wait(epfd_, events_, MAX_EVENTS, timeout);
    for (int i = 0; i < n; ++i) {
        if (events_[i].data.fd == listenFd_) {
            acceptConnection(); // 接受新连接
        } else {
            handleIO(events_[i]);  // 处理I/O事件
        }
    }
    processTimers(); // 处理定时任务
}
```

同时引入Socket连接池复用连接对象，避免频繁创建销毁的系统调用开销。

**结果：** 内存占用从原来的线程模型大幅下降，同时稳定支撑100+并发连接。在ARM平台的有限资源下完全够用，CPU利用率也更稳定。

## 深入原理

### epoll 的工作原理

epoll 是 Linux 提供的高效I/O多路复用机制，相比 select/poll 有两个核心优势：
1. **O(1) 事件通知**：内核通过回调机制把就绪的fd放入就绪列表，不需要遍历全部fd
2. **无fd数量限制**：select 默认最多1024个fd，epoll 没有硬限制

两种触发模式：
- **LT（水平触发，默认）**：只要fd有数据可读就持续通知，编程简单但可能重复通知
- **ET（边沿触发）**：仅在状态变化时通知一次，性能更好但必须一次性读完数据

### 回调地狱与解决方案

事件驱动的最大痛点是回调嵌套。实际项目中的缓解方法：
- **状态机**：用状态枚举代替嵌套回调，每个状态对应一个处理函数
- **协程**：C++20 协程或 Boost.Asio 的 coroutine，用同步写法做异步操作
- **Promise/Future**：链式调用代替嵌套

### 混合模型：事件循环 + 线程池

纯事件驱动遇到CPU密集任务会阻塞整个循环。实际架构通常是：
- 主线程运行事件循环，处理I/O
- 耗时计算任务丢给线程池
- 线程池完成后通过事件通知主线程

这是 Nginx、Redis、Qt 等项目采用的通用架构模式。

### Qt 的事件循环

Qt 的 `QEventLoop` 本质就是事件驱动模型。`QApplication::exec()` 启动主事件循环，信号槽、定时器、Socket通知都通过事件分发。Qt 的 `QSocketNotifier` 封装了底层的 epoll/select，让开发者不需要直接操作系统API。

## 面试表达建议

**开头：** "事件驱动和多线程是两种并发模型。事件驱动用单线程事件循环处理I/O，内存开销低，适合I/O密集和资源受限场景；多线程能利用多核，适合CPU密集任务。实际项目中常用混合模型。"

**项目关联：** "营业厅项目的ARM平台只有512MB内存，HTTP服务器从每连接一线程改为epoll事件驱动后，内存占用大幅降低，稳定支持100+并发连接。耗时操作才交给工作线程池。"

**追问准备：**
- epoll和select的区别？→ select用fd_set遍历，O(n)且有1024限制；epoll回调通知，O(1)无限制
- 事件驱动怎么处理CPU密集任务？→ 交给线程池，完成后通过事件通知主循环
- Qt的信号槽和事件循环什么关系？→ 同线程信号槽是直接调用，跨线程时通过事件队列投递
