# 适配器模式在设备接入中怎么用？怎么统一不同厂商的设备接口？

## 知识点速览

适配器模式（Adapter Pattern）属于结构型设计模式，核心作用是**将一个类的接口转换成客户端期望的另一种接口**，让原本因接口不兼容而无法协作的类能够一起工作。

**两种实现方式：**

| 类型 | 实现手段 | 耦合度 | 适用场景 |
|------|---------|--------|---------|
| 类适配器 | 多重继承 | 高 | 需要覆盖被适配类行为 |
| 对象适配器 | 组合持有 | 低（推荐） | 需要适配多个类、运行时替换 |

**设备接入的典型问题：** 不同厂商提供的SDK接口命名、参数格式、返回值类型完全不同。比如厂商A用 `openModbus(int, int)` 连接，厂商B用 `init(string, Config)` 连接。上层业务代码如果直接调用这些接口，每接入一个新设备就要改大量代码。

**解决思路：** 定义统一的设备接口（IDevice），为每个厂商的SDK写一个适配器类，内部将统一接口的调用转发给具体的SDK方法。

## 我的实战经历

**公司/项目：** 江苏思行达 · 营业厅柜外交互终端

**问题背景：** 营业厅终端需要管理15+种外设——读卡器、密码键盘、凭条打印机、二维码扫描器等，每种设备来自不同厂商，SDK接口千差万别。初版代码中业务逻辑直接调用各厂商的SDK函数，代码里到处是 `if (厂商A) ... else if (厂商B) ...` 的分支，每接入一个新设备或更换厂商，都需要改动多处业务代码。

**解决方案：** 设计统一的 `IDevice` 接口，为每个厂商编写适配器：

```cpp
// 统一设备接口
class IDevice {
public:
    virtual bool connect(const QString& addr) = 0;
    virtual QByteArray read() = 0;
    virtual bool write(const QByteArray& cmd) = 0;
    virtual void disconnect() = 0;
    virtual ~IDevice() = default;
};

// 厂商A的RS485读卡器适配器
class VendorACardReader : public IDevice {
    VendorADriver driver_;
public:
    bool connect(const QString& addr) override {
        return driver_.openModbus(addr.toInt(), 9600);
    }
    QByteArray read() override {
        auto regs = driver_.readHoldingRegisters(0x00, 10);
        return convertToBytes(regs);
    }
    // ...
};
```

配合工厂模式，通过配置文件指定每个工位使用哪个厂商的设备，运行时动态创建对应的适配器实例。业务代码只面向 `IDevice` 接口编程，完全不感知具体厂商。

**结果：** 新设备接入只需编写一个适配器类 + 在配置文件中注册，接入周期从原来的1周缩短到2-3天，缩短约50%。业务代码零改动，设备切换也变成了改配置项的事情。

## 深入原理

### 对象适配器 vs 类适配器

```cpp
// 对象适配器（组合方式，推荐）
class Adapter : public ITarget {
    Adaptee adaptee_; // 持有被适配对象
public:
    void request() override {
        adaptee_.specificRequest(); // 委托调用
    }
};

// 类适配器（多继承方式）
class Adapter : public ITarget, private Adaptee {
public:
    void request() override {
        specificRequest(); // 直接调用继承来的方法
    }
};
```

对象适配器更灵活：可以适配 Adaptee 的子类，运行时可替换被适配对象，符合组合优于继承的原则。

### 适配器 vs 外观(Facade) vs 桥接(Bridge)

| 模式 | 目的 | 场景 |
|------|------|------|
| 适配器 | 转换已有接口 | 接入第三方SDK |
| 外观 | 简化复杂子系统 | 提供统一入口 |
| 桥接 | 分离抽象与实现 | 多维度独立变化 |

适配器解决的是"已有的接口不匹配"问题；外观解决的是"子系统太复杂，需要简化"问题；桥接解决的是"抽象和实现需要独立变化"问题。

### 适配器模式与工厂模式配合

实际项目中适配器很少单独使用。通常配合工厂模式根据配置或运行时参数创建具体适配器，上层代码只依赖抽象接口，实现了开闭原则——对扩展开放（加新适配器），对修改关闭（不改业务代码）。

## 面试表达建议

**开头定义：** "适配器模式把一个类的接口转换成客户端期望的接口，解决接口不兼容问题。设备接入场景中，不同厂商SDK接口各异，通过适配器统一成一个IDevice接口，业务代码只面向这个接口编程。"

**项目关联：** "营业厅项目管理15+种外设，每种来自不同厂商。我为每个厂商写了适配器类，配合工厂模式动态创建。新设备接入只需写一个适配器，接入周期缩短50%，业务代码零改动。"

**追问准备：**
- 适配器和代理模式区别？→ 适配器转换接口，代理控制访问，接口通常相同
- 如果适配器太多怎么办？→ 配合反射或注册表机制自动发现，避免手动管理
- 双向适配器？→ 同时实现两个接口，互相适配，但复杂度高，慎用
