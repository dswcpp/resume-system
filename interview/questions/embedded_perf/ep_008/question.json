{
  "id": "ep_008",
  "question": "看门狗和异常恢复机制怎么设计？进程崩溃了怎么自动拉起？",
  "tags": ["看门狗", "异常恢复", "稳定性", "嵌入式"],
  "difficulty": 2,
  "hint": "分软件看门狗和硬件看门狗两种",
  "answer": "**看门狗分类：**\n1. **硬件看门狗**：MCU/SoC内置，超时不喂狗则硬件复位\n2. **软件看门狗**：守护进程监控目标进程，异常时自动重启\n\n**软件看门狗设计：**\n```\n守护进程(Watchdog)\n  ├── 定期检查目标进程是否存活（kill -0 或心跳）\n  ├── 超时未响应 → 记录日志 → 杀掉进程 → 重新启动\n  ├── 启动失败 → 等待间隔指数递增 → 重试\n  └── 连续失败超过阈值 → 告警通知\n```\n\n**异常捕获机制：**\n- **C++层**：try-catch捕获std::exception，记录堆栈信息\n- **系统层**：注册SIGSEGV/SIGABRT信号处理器，崩溃前保存现场\n- **进程级**：systemd/supervisor管理进程，Restart=always\n\n**营业厅项目实践：**\n- 主进程注册信号处理器，崩溃时写入crash log\n- 守护脚本每5秒检查主进程，异常则拉起并通知运维\n- 配合分级日志实现远程问题定位",
  "source": "简历：软件看门狗、异常捕获、远程问题定位"
}
