# 环形缓冲区设计与应用

## 知识点速览
- 环形缓冲区（Ring Buffer / Circular Buffer）是固定大小的FIFO数据结构
- 核心：head（读指针）和 tail（写指针）在固定数组上循环移动
- 适用场景：生产者-消费者模式、实时数据流、网络包缓冲
- 容量设为2的幂可以用位运算代替取模，提高性能

## 我的实战经历
在T95项目的TEV检测模块中，需要处理1MHz采样率的波形数据：
- 采集线程以1MHz频率将采样点写入环形缓冲区
- 处理线程从缓冲区批量读取数据进行分析
- 缓冲区大小设为2^20（约100万个采样点，对应约1秒的数据）
- 使用SPSC（单生产者单消费者）无锁设计，避免锁开销
- 当缓冲区满时采用覆盖策略，因为实时显示场景下旧数据可以丢弃

## 深入原理

### 基本结构
```
缓冲区数组: [0] [1] [2] [3] [4] [5] [6] [7]
             ↑                   ↑
            head                tail
            (读)                (写)
```

### 满/空判断的两种方式
1. **浪费一个位置法**：满条件为 (tail + 1) % N == head，这样空和满不会混淆
2. **计数器法**：用size变量记录当前元素数，head和tail可以自由增长

### 2的幂优化
```cpp
// 普通取模（除法运算，较慢）
index = pos % capacity;
// 位运算取模（capacity是2的幂时等价，快很多）
index = pos & (capacity - 1);
```

### 无锁SPSC环形队列的内存序
```cpp
// 生产者写入
tail_.store(new_tail, std::memory_order_release);
// 消费者读取
head_.load(std::memory_order_acquire);
```
- release保证：写入data[]的操作在store(tail)之前完成
- acquire保证：load(tail)之后才能读取data[]的内容
- 配对使用形成happens-before关系，保证数据可见性

### 覆盖策略对比
| 策略 | 满时行为 | 适用场景 |
|------|---------|---------|
| 阻塞等待 | 生产者等待消费者 | 不能丢数据（文件传输） |
| 返回失败 | push返回false | 调用者自行处理 |
| 覆盖最旧 | 移动head，覆盖旧数据 | 实时显示（波形、视频） |
| 丢弃最新 | 丢弃本次写入 | 限流场景 |

## 面试表达建议
先画图说明环形缓冲区的结构（head/tail两个指针），然后说设计要点（2的幂优化、满空判断），接着说项目中的用法（TEV模块1MHz采样），最后可以引申到无锁队列的内存序问题展示深度。
