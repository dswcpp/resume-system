# 交易数据安全怎么保障的？消息持久化和断点续传怎么做？

## 知识点速览

银行交易场景对数据安全有三个核心要求：**传输不被窃听**（加密）、**敏感信息不泄露**（脱敏）、**交易不能丢失**（持久化+断点续传）。

**四层保障体系：**

| 层面 | 手段 | 目的 |
|------|------|------|
| 传输加密 | AES-128/256 + TLS | 防窃听、防篡改 |
| 数据脱敏 | 卡号掩码、密码不落盘 | 防泄露 |
| 消息持久化 | SQLite本地队列 | 防丢失 |
| 断点续传 | 唯一ID + ACK确认 + 重发 | 弱网可靠性 |

**消息生命周期：**
```
生成 → 加密 → 持久化(SQLite) → 发送 → 等ACK → 标记完成
                                    ↓ 失败
                               保留队列 → 网络恢复后重发
```

## 我的实战经历

**公司/项目：** 江苏思行达 · 营业厅柜外交互终端

**问题背景：** 柜外交互终端处理银行业务——客户在终端上刷卡、输密码、办理业务，终端和银行后台之间传输交易报文。这个场景有两个铁律：一是敏感数据绝对不能泄露，二是交易数据绝对不能丢失。终端部署在银行网点，网络环境不完全可控，存在偶尔断网、网络抖动的情况。

**数据安全设计：**

**1. 传输加密**
交易报文在发送前使用AES-256加密。密钥在终端出厂时通过安全通道预置，存储在加密芯片中，程序运行时从加密芯片读取。密钥定期更换——银行后台推送新密钥，终端用旧密钥解密后存入加密芯片。通信链路本身也走TLS，形成双重加密。

**2. 敏感数据脱敏**
日志和本地存储中，卡号只保留前6后4位（`622588******1234`），中间用星号替代。密码全程不出现在任何日志、文件、内存dump中——密码在密码键盘硬件内部加密，终端只传输密文，不接触明文。

**3. 消息持久化**
交易报文在发送前先写入本地SQLite数据库：

```sql
CREATE TABLE msg_queue (
    id INTEGER PRIMARY KEY,
    msg_id TEXT UNIQUE,      -- 全局唯一消息ID
    seq_no INTEGER,          -- 序号
    payload BLOB,            -- 加密后的报文
    status INTEGER DEFAULT 0,-- 0:待发送 1:已发送待确认 2:已完成
    created_at DATETIME,
    retry_count INTEGER DEFAULT 0
);
```

发送流程：报文加密 → 写入SQLite（status=0）→ 发送 → 更新status=1 → 收到ACK → 更新status=2。任何一步失败，报文都不会丢失。

**4. 断点续传**
网络恢复后，查询SQLite中 `status < 2` 的消息，按 `seq_no` 顺序重新发送。接收方通过 `msg_id` 去重——如果收到重复的消息ID，直接返回ACK但不重复处理。重发使用指数退避策略，避免网络刚恢复时大量重发造成拥塞。

**结果：** 经过银行的安全审计，加密和脱敏方案通过合规检查。在实际运行中，即使遇到网络短暂中断（几秒到几分钟），交易数据零丢失。SQLite持久化队列在终端意外断电重启后也能恢复未完成的交易。

## 深入原理

### AES加密的工作模式选择

AES是分组加密算法，需要选择工作模式：
- **ECB**：每个分组独立加密，相同明文产生相同密文，不安全
- **CBC**：每个分组与前一个密文异或后加密，需要IV，常用
- **GCM**：带认证的加密，同时保证机密性和完整性，推荐

项目中使用AES-256-CBC模式，每条消息用随机IV，IV和密文一起传输。

### 消息持久化的WAL模式

SQLite默认用回滚日志（rollback journal），写入时会锁整个数据库。项目中开启WAL（Write-Ahead Logging）模式，允许读写并发——业务线程查询队列状态时不会被写入操作阻塞：

```sql
PRAGMA journal_mode=WAL;
```

WAL模式下写入性能也更好，适合频繁插入的消息队列场景。

### 幂等性设计

断点续传必然导致消息重发，接收方必须保证幂等性——同一笔交易处理多次和处理一次的结果相同。实现方式：
1. 每条消息有全局唯一的 `msg_id`
2. 接收方维护已处理消息的ID集合（或用数据库唯一约束）
3. 收到重复ID时返回ACK但跳过业务处理

### 加密密钥的安全存储

密钥不能存在普通文件或代码中。安全级别从低到高：
- 配置文件（不安全，明文可读）
- 操作系统密钥库（Windows DPAPI / Linux keyring）
- 硬件加密芯片（最安全，密钥不出芯片）

银行终端使用加密芯片方案，密钥在芯片内部完成加解密运算，即使终端被物理拆解也无法提取密钥。

## 面试表达建议

**开头：** "交易数据安全从四个层面保障：AES-256加密防窃听，敏感数据脱敏防泄露，SQLite持久化队列防丢失，断点续传加ACK确认保证弱网可靠性。"

**重点讲持久化流程：** "交易报文在发送前先写入本地SQLite——先持久化再发送，这样即使发送过程中断电或网络断了，报文也不会丢。网络恢复后自动查询未完成的消息重发，接收方通过消息ID去重保证幂等。"

**追问准备：**
- AES的密钥怎么管理？→ 存在加密芯片中，定期通过安全通道更换
- 持久化用SQLite会不会太慢？→ WAL模式下写入很快，交易量不是海量级别，完全够用
- 如果消息一直发不出去怎么办？→ 重试次数上限 + 告警通知运维 + 本地队列有容量限制
